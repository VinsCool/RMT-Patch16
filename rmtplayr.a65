;*
;* Raster Music Tracker, RMT Atari routine version Patch16-3.2
;* (c) Radek Sterba, Raster/C.P.U., 2002 - 2009
;* http://raster.atari.org
;*
;* Unofficial version by VinsCool, 2021 - 2022
;* https://github.com/VinsCool/RMT-Patch16
;*
;* TO DO: A lot... So much to re-order and cleanup...
;* I must recalculate everything, once the full code cleanup and optimisation is done.
;* Currently, all infos are incorrect due to the massive amount of changes I have done into the code.
;* I apologise for the inconvenience, I am doing my best to clean everything to make sense again.
;*

;---------------------------------------------------------------------------------------------------------------------------------------------;

;* RMT FEATures definitions file
	icl "rmt_feat.a65"
	
;* For optimizations of RMT player routine to concrete RMT module only!

;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of RMT definitions...

	IFT STEREOMODE==1
TRACKS			equ 8
	ELS
TRACKS			equ 4
	EIF
	
PLAYER			equ $3400
TABLES			equ $B000
INSTRPAR		equ 12

;* RMT ZeroPage addresses
	org 203	     	;* org $CB
	
p_tis
p_instrstable		org *+2
p_trackslbstable	org *+2
p_trackshbstable	org *+2
p_song			org *+2
ns			org *+2
nr			org *+2
nt			org *+2
reg1			org *+1
reg2			org *+1
reg3			org *+1
tmp			org *+1

	IFT FEAT_COMMAND2
frqaddcmd2		org *+1
	EIF

; these 2 pointer hijacking pieces could be implemented better...

	IFT FEAT_FULL_16BIT||FEAT_BASS16
pointer16bitlo		org *+2
	EIF
	
	IFT FEAT_FULL_SAWTOOTH
sawtoothtables		org *+2
	EIF 
	
;* possible improvement: setting variables after the RMT driver itself? 
;* That would make adjustments easier to manage, if this works as I expect...

	IFT TRACKS>4			
	org PLAYER-$400+$40
	ELS
	org PLAYER-$400+$e0
	EIF
	
track_variables

trackn_db		org *+TRACKS
trackn_hb		org *+TRACKS
trackn_idx		org *+TRACKS
trackn_pause		org *+TRACKS
trackn_note		org *+TRACKS
trackn_volume		org *+TRACKS
trackn_volumeenvelope	org *+TRACKS
trackn_command		org *+TRACKS
trackn_effectparameter	org *+TRACKS
trackn_shiftfrq		org *+TRACKS

	IFT FEAT_PORTAMENTO
trackn_portafrqc 	org *+TRACKS
trackn_portafrqa 	org *+TRACKS
trackn_portaspeed 	org *+TRACKS
trackn_portaspeeda 	org *+TRACKS
trackn_portadepth 	org *+TRACKS
	EIF
	
trackn_instrx2		org *+TRACKS
trackn_instrdb		org *+TRACKS
trackn_instrhb		org *+TRACKS
trackn_instridx		org *+TRACKS
trackn_instrlen		org *+TRACKS
trackn_instrlop		org *+TRACKS
trackn_instrreachend	org *+TRACKS
trackn_volumeslidedepth org *+TRACKS
trackn_volumeslidevalue org *+TRACKS

	IFT FEAT_VOLUMEMIN
trackn_volumemin	org *+TRACKS
	EIF
	
FEAT_EFFECTS equ FEAT_EFFECTVIBRATO||FEAT_EFFECTFSHIFT
	IFT FEAT_EFFECTS
trackn_effdelay		org *+TRACKS
	EIF
	
	IFT FEAT_EFFECTVIBRATO
trackn_effvibratoa	org *+TRACKS
	EIF
	
	IFT FEAT_EFFECTFSHIFT
trackn_effshift		org *+TRACKS
	EIF
	
trackn_tabletypespeed 	org *+TRACKS

	IFT FEAT_TABLEMODE
trackn_tablemode	org *+TRACKS
	EIF
	
trackn_tablenote	org *+TRACKS
trackn_tablea		org *+TRACKS
trackn_tableend		org *+TRACKS

	IFT FEAT_TABLEGO
trackn_tablelop		org *+TRACKS
	EIF
	
trackn_tablespeeda	org *+TRACKS

	IFT FEAT_FILTER
trackn_filter		org *+TRACKS		;* POTENTIAL OPTIMISATION: it is NOT necessary to use all tracks... only channel 1 and 2 will use it to offset the other...
	EIF
	
	IFT FEAT_TABLE_MANUAL
trackn_pointertable	org *+TRACKS	
	EIF
	
	IFT FEAT_AUDCTLMANUALSET
trackn_audctl		org *+TRACKS
	EIF	
	
trackn_audf		org *+TRACKS
trackn_audc		org *+TRACKS

v_aspeed		org *+1

track_endvariables

;* end of RMT definitions...
	
;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of RMT data... maybe this could be moved elsewhere, much like the tuning tables?
	
	org PLAYER-$0200	; I need to improve the label organisation here as well, also do I really need to org there? my memory is hazy, why did even do this...?
	
	IFT FEAT_AUDCTLMANUALSET
AUDCTLBITS	; bits to test for AUDCTL lookup tables
POLY9	dta $80	; bit 7
CH1_179	dta $40	; bit 6
CH3_179	dta $20	; bit 5
JOIN_12	dta $10	; bit 4
JOIN_34	dta $08	; bit 3
HPF_CH1	dta $04	; bit 2
HPF_CH2	dta $02	; bit 1
CLOCK15	dta $01	; bit 0
	EIF	
	
TABLES_MSB
DISTORTIONS equ *+1
	dta >PAGE_DISTORTION_A,$00
	dta >PAGE_DISTORTION_2,$20
	dta >PAGE_DISTORTION_A,$40
	dta >PAGE_DISTORTION_A,$A0
	dta >PAGE_DISTORTION_A,$80
	dta >PAGE_DISTORTION_A,$A0
	dta >PAGE_DISTORTION_C,$C0
	dta >PAGE_DISTORTION_E,$C0
	
	IFT FEAT_EFFECTVIBRATO
vibtabbeg 
	dta 0,vib1-vib0,vib2-vib0,vib3-vib0
vib0	dta 0
vib1	dta 1,-1,-1,1
vib2	dta 1,0,-1,-1,0,1
vib3	dta 1,1,0,-1,-1,-1,-1,0,1,1
vibtabnext
	dta vib0-vib0+0
	dta vib1-vib0+1,vib1-vib0+2,vib1-vib0+3,vib1-vib0+0
	dta vib2-vib0+1,vib2-vib0+2,vib2-vib0+3,vib2-vib0+4,vib2-vib0+5,vib2-vib0+0
	dta vib3-vib0+1,vib3-vib0+2,vib3-vib0+3,vib3-vib0+4,vib3-vib0+5,vib3-vib0+6,vib3-vib0+7,vib3-vib0+8,vib3-vib0+9,vib3-vib0+0
	EIF	
	
	org PLAYER-$0100	;* it may be possible to reduce this table by half the size it is... this was something I did for the older RMT Patch16 code, so the option is still valuable...
volumetab
	dta $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
	dta $00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
	dta $00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01,$02,$02,$02,$02
	dta $00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02,$03,$03,$03
	dta $00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03,$04,$04
	dta $00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
	dta $00,$00,$01,$01,$02,$02,$02,$03,$03,$04,$04,$04,$05,$05,$06,$06
	dta $00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
	dta $00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07,$08
	dta $00,$01,$01,$02,$02,$03,$04,$04,$05,$05,$06,$07,$07,$08,$08,$09
	dta $00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$07,$07,$08,$09,$09,$0A
	dta $00,$01,$01,$02,$03,$04,$04,$05,$06,$07,$07,$08,$09,$0A,$0A,$0B
	dta $00,$01,$02,$02,$03,$04,$05,$06,$06,$07,$08,$09,$0A,$0A,$0B,$0C
	dta $00,$01,$02,$03,$03,$04,$05,$06,$07,$08,$09,$0A,$0A,$0B,$0C,$0D
	dta $00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0A,$0B,$0C,$0D,$0E
	dta $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F

;* end of RMT data...
	
;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of RMT jump table...

        org PLAYER			;* Possible improvement: give proper labels to each JMPs below... to avoid confusion, and also make things easier to map in memory, unless the destination is being JSR'ed directly...

RASTERMUSICTRACKER
	jmp rmt_init			;* Must be run first, to clear memory and initialise the player... Once this is done, run rmt_play afterwards, or Set_Pokey if you want to manually time certain things.
	jmp rmt_play			;* One play each subroutine call. SetPokey is executed first, then all the play code is ran once, until the RTS. rmt_play could be called multiple times per frame if wanted.
	jmp rmt_p3			;* Similar to rmt_play, but will also skip SetPokey and the instruments/songlines/tracklines initialisation, very useful for playing simple things.
	jmp rmt_silence			;* Run this to stop the driver, and reset all POKEY registers to 0. This is also part of rmt_init when it is executed first.
	jmp SetPokey			;* Run to copy the contents of the Shadow POKEY registers (v_audctl, v_skctl, trackn_audf,x etc) into the real ones. Will be run first each time rmt_play is called.
	IFT FEAT_SFX
	jmp rmt_sfx			;* A=note(0,..,60),X=channel(0,..,3 or 0,..,7),Y=instrument*2(0,2,4,..,126)
	EIF
	
;* end of RMT jump table... from here, all the main driver code is being executed, have fun playing around! ;)
	
;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of rmt_init code...
	
rmt_init
	stx ns
	sty ns+1
	IFT FEAT_NOSTARTINGSONGLINE==0
	pha	; backup the song line into the stack for now... I wonder if I could just use tmp in zeropage instead...
	EIF
		
	IFT track_endvariables-track_variables>255	; more than 255 variables in memory...
	ldy #0
	tya
ri0	
	sta track_variables,y
	sta track_endvariables-$100,y
	iny
	bne ri0
	
	ELS						
	ldy #track_endvariables-track_variables
	lda #0
ri0	
	sta track_variables-1,y
	dey
	bne ri0
	EIF
	
	ldy #4
	lda (ns),y
	sta v_maxtracklen
	iny
	IFT FEAT_CONSTANTSPEED==0
	lda (ns),y
	sta v_speed
	EIF
	IFT FEAT_INSTRSPEED==0
	iny
	lda (ns),y
	sta v_instrspeed
	sta v_ainstrspeed
	ELI FEAT_INSTRSPEED>1
	lda #FEAT_INSTRSPEED
	sta v_ainstrspeed
	EIF
	ldy #8
ri1	
	lda (ns),y
	sta p_tis-8,y
	iny
	cpy #8+8
	bne ri1
	IFT FEAT_NOSTARTINGSONGLINE==0
	pla
	pha
	IFT TRACKS>4
	asl @
	asl @
	asl @
	clc
	adc p_song
	sta p_song
	pla
	php
	and #$e0
	asl @
	rol @
	rol @
	rol @
	ELS
	asl @
	asl @
	clc
	adc p_song
	sta p_song
	pla
	php
	and #$c0
	asl @
	rol @
	rol @
	EIF
	plp
	adc p_song+1
	sta p_song+1
	EIF
	jsr GetSongLineTrackLineInitOfNewSetInstrumentsOnlyRmtp3
	
;* end of rmt_init code... rmt_silence will always be executed after the JSR above.
	
;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* start of rmt_silence code...
	
rmt_silence
	IFT STEREOMODE>0
	lda #0
	sta $d208
	sta $d218
	ldy #3
	sty $d20f
	sty $d21f
	ldy #8
si1	
	sta $d200,y
	sta $d210,y
	dey
	bpl si1
	ELS
	lda #0
	sta $d208
	ldy #3
	sty $d20f
	ldy #8
si1	
	sta $d200,y	
	dey
	bpl si1
	EIF
	
	IFT FEAT_IS_TRACKER 		; reset the tables pointers 
	lda #<frqtabsawtooth_ch1	
	sta saw_ch1
	lda #<frqtabsawtooth_ch3
	sta saw_ch3	
	lda #$0A			
	sta bass16_pointer 
	lda #3				; reset the SKCTL state to normal
	sta v_skctl
	sta v_skctl2	
	EIF	

	IFT FEAT_INSTRSPEED==0
	lda #$ff
v_ainstrspeed equ *-1			; return instrument speed, does not seem to matter after rmt_init?
	ELS
	lda #FEAT_INSTRSPEED
	EIF
	rts
	
;* end of rmt_silence code...
	
;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* start of mainloop code here... most of it is related to the songlines, tracklines and instruments initialisation...
	
GetSongLineTrackLineInitOfNewSetInstrumentsOnlyRmtp3
GetSongLine
	ldx #0
	stx v_abeat			; set the pattern row to 0 for the new songline... This could be exploited with an effect command related to premature pattern end, or pattern goto...
nn0
nn0_a
        IFT FEAT_IS_VISUALP		; RMT Visualiser hack for displaying the songline number, this is 100% useless but cool to have nonetheless.
	lda p_song
	sub MODUL+14 
	sta v_ord			; this variable only exists in rmtvis, this is what will be used to display the songline number
	lda p_song+1
	sbc MODUL+15
	lsr @
	ror v_ord
	lsr @
	ror v_ord
	IFT TRACKS>4
	lsr @
	ror v_ord
	EIF
	EIF
nn0_b
	IFT FEAT_IS_SIMPLEP
	IFT EXPORTXEX			; Simple RMT Player hack for colour cycling, change the rasterbar colour every new pattern played
	lda loop+1			; the #RASTERBAR colour defined will be loaded there specifically
	add #16				; offset the value by #$10 for a simple colour shuffle
	sta loop+1   			; store back where it was loaded, overwriting the previous value
	EIF 
	EIF
	
nn1	
	txa
	tay
	lda (p_song),y
	cmp #$fe			; #$FE = Goto songline, #$FF = Empty track
	bcs nn2				; branch if greater or equal
	tay
	lda (p_trackslbstable),y
	sta trackn_db,x
	lda (p_trackshbstable),y
nn1a 	
	sta trackn_hb,x
	lda #0
	sta trackn_idx,x
	lda #1
nn1a2 	
	sta trackn_pause,x		; #1 is a new note, #0 is no new note
	lda #$80
	sta trackn_instrx2,x		; #$80 is negative, will BMI when encountered, meaning no new instrument initialisation
	inx	
	cpx #TRACKS
	bne nn1
	lda p_song
	clc	
	adc #TRACKS
	sta p_song
	bcc GetTrackLine
	inc p_song+1
	
nn1b
	jmp GetTrackLine
nn2
	beq nn3				; branch if equal to #$FE, this is a Goto songline command
nn2a
	lda #0				; used to set the instrument to 0, meaning no new note
	beq nn1a2			; unconditional
nn3
	ldy #2
	lda (p_song),y
	tax
	iny
	lda (p_song),y
	sta p_song+1
	stx p_song
	ldx #0
	beq nn0
	
GetTrackLine
oo0
oo0a
	IFT FEAT_CONSTANTSPEED==0
	lda #$ff
v_speed equ *-1
	sta v_bspeed
	EIF
	ldx #-1
oo1
	inx
	dec trackn_pause,x
	bne oo1x
oo1b
	lda trackn_db,x
	sta ns
	lda trackn_hb,x
	sta ns+1
oo1i
	ldy trackn_idx,x
	inc trackn_idx,x
	lda (ns),y
	sta reg1
	and #$3f
	cmp #61
	beq oo1a
	bcs oo2
	sta trackn_note,x
	iny
	lda (ns),y
	lsr @
	and #$3f*2
	sta trackn_instrx2,x
oo1a
	lda #1
	sta trackn_pause,x
	ldy trackn_idx,x
	inc trackn_idx,x
	lda (ns),y
	lsr @
	ror reg1
	lsr @
	ror reg1
	lda reg1
	IFT FEAT_GLOBALVOLUMEFADE
	sec
	sbc #$00
RMTGLOBALVOLUMEFADE equ *-1
	bcs voig
	lda #0
voig
	EIF
	and #$f0
	sta trackn_volume,x
oo1x	
	cpx #TRACKS-1
	bne oo1
	IFT FEAT_CONSTANTSPEED==0
	lda #$ff
v_bspeed equ *-1
	sta v_speed
	ELS
	lda #FEAT_CONSTANTSPEED
	EIF
	sta v_aspeed
	jmp InitOfNewSetInstrumentsOnly
	
oo2
	cmp #63
	beq oo63
	lda reg1
	and #$c0
	beq oo62_b
	asl @
	rol @
	rol @
	sta trackn_pause,x
	jmp oo1x
oo62_b
	iny
	lda (ns),y
	sta trackn_pause,x
	inc trackn_idx,x
	jmp oo1x
oo63
	lda reg1
	IFT FEAT_CONSTANTSPEED==0
	bmi oo63_1X
	iny
	lda (ns),y
	sta v_bspeed
	inc trackn_idx,x
	jmp oo1i
oo63_1X
	EIF
	cmp #255
	beq oo63_11
	iny
	lda (ns),y
	sta trackn_idx,x
	jmp oo1i
oo63_11
	jmp GetSongLine
	
p2xrmtp3	
	jmp rmt_p3
p2x0 	
	dex
	bmi p2xrmtp3
	
InitOfNewSetInstrumentsOnly
p2x1 	
	ldy trackn_instrx2,x
	bmi p2x0		; if negative, there is no new instrument to initialise for this channel
	
;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of RMT_SFX code...
	
	IFT FEAT_SFX
	jsr SetUpInstrumentY2
	jmp p2x0
rmt_sfx
	sta trackn_note,x
	lda #$f0		;* sfx note volume*16
RMTSFXVOLUME equ *-1		;* label for sfx note volume parameter overwriting
	sta trackn_volume,x
	EIF
	
;* end of RMT_SFX code...

;---------------------------------------------------------------------------------------------------------------------------------------------;
	
SetUpInstrumentY2
	lda (p_instrstable),y
	sta trackn_instrdb,x
	sta nt
	iny
	lda (p_instrstable),y
	sta trackn_instrhb,x
	sta nt+1
	IFT FEAT_FILTER
	lda #1
	sta trackn_filter,x
	EIF
	IFT FEAT_TABLEGO
	IFT FEAT_FILTER
	tay
	ELS
	ldy #1
	EIF
	lda (nt),y
	sta trackn_tablelop,x
	iny
	ELS
	ldy #2
	EIF
	lda (nt),y
	sta trackn_instrlen,x
	iny
	lda (nt),y
	sta trackn_instrlop,x
	iny
	lda (nt),y
	sta trackn_tabletypespeed,x
	IFT FEAT_TABLETYPE||FEAT_TABLEMODE
	and #$3f
	EIF
	sta trackn_tablespeeda,x
	IFT FEAT_TABLEMODE
	lda (nt),y
	and #$40
	sta trackn_tablemode,x
	EIF
	IFT FEAT_AUDCTLMANUALSET
	iny
	lda (nt),y
	sta trackn_audctl,x
	iny
	ELS
	ldy #6
	EIF
	lda (nt),y
	sta trackn_volumeslidedepth,x
	IFT FEAT_VOLUMEMIN
	iny
	lda (nt),y
	sta trackn_volumemin,x
	IFT FEAT_EFFECTS
	iny
	EIF
	ELS
	IFT FEAT_EFFECTS
	ldy #8
	EIF
	EIF
	IFT FEAT_EFFECTS
	lda (nt),y
	sta trackn_effdelay,x
	IFT FEAT_EFFECTVIBRATO
	iny
	lda (nt),y
	tay
	lda vibtabbeg,y
	sta trackn_effvibratoa,x
	EIF
	IFT FEAT_EFFECTFSHIFT
	ldy #10
	lda (nt),y
	sta trackn_effshift,x
	EIF
	EIF
	IFT FEAT_TABLE_MANUAL	; Manual tuning table loaded from instruments, based on the unused 12th byte, this is not yet fully implemented into RMT
	ldy #11
	lda (nt),y
	sta trackn_pointertable,x	
	EIF
	lda #128
	sta trackn_volumeslidevalue,x
	sta trackn_instrx2,x
	asl @
	sta trackn_instrreachend,x
	sta trackn_shiftfrq,x
	tay
	lda (nt),y
	sta trackn_tableend,x
	adc #0
	sta trackn_instridx,x
	lda #INSTRPAR
	sta trackn_tablea,x
	tay
	lda (nt),y
	sta trackn_tablenote,x

	IFT FEAT_SFX||FEAT_IS_TRACKER
	rts 			
;* a rts is mandatory for the 'tracker.obx' binary, else a lot of things break in RMT! 
;* look inside 'rmtextra.a65' for the exclusive tracker.obx code
	ELS
	jmp p2x0		; go process the next channel's instrument
	EIF
	
rmt_play
rmt_p0
	jsr SetPokey
	
rmt_p1
	IFT FEAT_INSTRSPEED==0||FEAT_INSTRSPEED>1
	dec v_ainstrspeed
	bne rmt_p3
	EIF
	IFT FEAT_INSTRSPEED==0
	lda #$ff
v_instrspeed	equ *-1
	sta v_ainstrspeed
	ELI FEAT_INSTRSPEED>1
	lda #FEAT_INSTRSPEED
	sta v_ainstrspeed
	EIF
	
rmt_p2
	dec v_aspeed
	bne rmt_p3
	inc v_abeat
	lda #$ff
v_abeat equ *-1
	cmp #$ff
v_maxtracklen equ *-1
	beq p2o3
	jmp GetTrackLine
p2o3
	jmp GetSongLineTrackLineInitOfNewSetInstrumentsOnlyRmtp3

rmt_p3	
	ldx #TRACKS-1
	
;* combining the aggressive init and rmt_p3 in 1 thing, this is now an even more aggressive approach! 
	
dodex	
	lda trackn_instrhb,x
	beq dexnext			; process the next channel's bytes immediately if empty
	sta ns+1
	lda trackn_instrdb,x
	sta ns
	ldy trackn_instridx,x
	lda (ns),y			; volume byte	
	sta trackn_volumeenvelope,x	; sta reg1
	iny
	lda (ns),y			; command and distortion byte
	sta trackn_command,x		; sta reg2
	iny
	lda (ns),y			; $XY parameter byte
	sta trackn_effectparameter,x	; sta reg3
	iny
	tya
	cmp trackn_instrlen,x
	bcc dodex_a
	beq dodex_a
	lda #$80
	sta trackn_instrreachend,x
	lda trackn_instrlop,x
dodex_a
	sta trackn_instridx,x

	IFT FEAT_AUDCTLMANUALSET&&FEAT_COMMAND7
dex_cmd7	
	lda trackn_command,x
	and #$70			; clear distortion and other bits
	cmp #$70 			; command 7? 
	bne dexnext			; skip if not equal
	lda trackn_effectparameter,x	
dex_xy
	cmp #$FD                	; failsafe -> Volume Only Mode or SKCTL toggle 
	bcs dexnext	        	; skip if above or equal #$FD 
	sta trackn_audctl,x     	; overwrite the previous value	
	EIF	
	
dexnext
	dex
	bpl dodex			; continue until x is negative
	ldx #TRACKS-1			; must get the tracks value again before the next part
	
pp0					; get AUDCTL as early as possible, properly this time!
	IFT FEAT_AUDCTLMANUALSET
	lda trackn_audctl+0
	ora trackn_audctl+1
	ora trackn_audctl+2
	ora trackn_audctl+3
	sta v_audctl	
	IFT TRACKS>4	
	lda trackn_audctl+4
	ora trackn_audctl+5
	ora trackn_audctl+6
	ora trackn_audctl+7
	sta v_audctl2	
	EIF	
pp0_a
	sta reg1			; backup the AUDCTL to the zeropage for quicker accesses later	
	ELS
	lda #0
	sta v_audctl
	IFT TRACKS>4
	sta v_audctl2
	EIF
	EIF

pp1					; copying the values to the zeropage to make things faster... but not all bytes need this...
	IFT TRACKS>4&&FEAT_AUDCTLMANUALSET
	cpx #3				; ch4, Left POKEY, specifically to verify we have the proper AUDCTL value in reg1!
	bne pp1_a			; if not equal, reg1 has the proper value already
	lda v_audctl			; if equal, get the proper AUDCTL value first
	sta reg1			; backup the AUDCTL again, for the Left POKEY channels
	EIF
pp1_a
	lda trackn_instrhb,x
	bne pp1_b			; continue if not equal 
	jmp ppnext			; skip this channel and process the next one
pp1_b
	lda trackn_command,x		; command and distortion byte
	sta reg2			; backup to the zeropage for quicker accesses
	lda trackn_effectparameter,x	; $XY parameter byte
	sta reg3			; backup to the zeropage for quicker accesses
	
pp2
	lda trackn_volumeenvelope,x	; volume envelope byte
	IFT TRACKS>4
	cpx #4
	bcc pp2s
	lsr @
	lsr @
	lsr @
	lsr @
	EIF
pp2s
	and #$0f
	ora trackn_volume,x
	tay
	lda volumetab,y
	sta tmp

;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of manual tables code (unfinished)...

	IFT FEAT_TABLE_MANUAL		; Manual tuning table loaded from instruments, this is currently not fully implemented into RMT...
	lda trackn_pointertable,x
	beq do_tuning_tables		; a value of 0 means no pointer will be used, thus, can be skipped immediately
	tay
	and #$0F
	ora #$B0
	sta nr+1			; Bx00, where x is manipulated
;* hack for Reverse-16 proof of concept, won't be used later		
	lda #0
	cpx #1
	bne stayzero
;* end hack
	tya
	and #$C0
stayzero	
	sta nr				; B0x0, where is manipulated
;* hack for Reverse-16 proof of concept, won't be used later	 
	cpx #0
	bne getdist
	lda tmp
	ora #$C0	
	jmp store_tables_lsb_c 
;* end of Reverse-16 hack, what is below should always be the same 
getdist	
	lda reg2
	and #$0e
	tay
	jmp store_tables_lsb_b
	EIF
	
;* end of manual tables code...
	
;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* start of the tuning tables code... 

do_tuning_tables
	lda reg2		; Distortion and Command
	and #$0E		; Only keep the Distortion bits
	tay			; will be used for the tables MSB pointer, and the Distortion itself	
	
	IFT FEAT_AUDCTLMANUALSET
	lda reg1		; AUDCTL backup 
	bne check_index 	; if not zero, process the channels index
	IFT FEAT_BASS16
	cpy #$06 		; Distortion 6?
	beq check_index		; channels MUST be checked, even with AUDCTL == 0, in order to process the BASS16 code properly!
	EIF
	jmp store_tables_lsb	; if 0, no flag to check, skip checking channels immediately!
	
	IFT FEAT_BASS16
hellyes
	jmp do_bass16		; process the BASS16 code from here
	EIF	
	IFT FEAT_FULL_16BIT
hellno				; Invalid 16-bit flag!
	lda #0			; clear the channel values
	sta trackn_audc,x
	sta trackn_audf,x
	jmp ppnext 		; skip this channel entirely 
	EIF	
	
check_index
	IFT TRACKS>4		; stereo mode
check_index_stereo	
	cpx #4			; are we in the right POKEY channels?
	bcc check_index_mono	; if x is lower than 4, we are not
	cpx #7			; ch4
	beq check_ch4
	cpx #6 			; ch3
	beq check_ch3
	cpx #5			; ch2
	beq check_ch2	
	bne check_ch1		; ch1 is unconditional, the other 3 channels were already tested!
	EIF
check_index_mono
	cpx #3			; ch4
	beq check_ch4
	cpx #2			; ch3
	beq check_ch3
	cpx #1			; ch2
	beq check_ch2		
				; ch1 is unconditional, the other 3 channels were already tested!
check_ch1 			
	bit CH1_179 
	beq get_15khz_flag
	IFT FEAT_FULL_16BIT
	bit JOIN_12
	beq get_179_flag
	bne hellno
	ELS
	bne get_179_flag
	EIF
	
check_ch2	
	IFT FEAT_FULL_16BIT||FEAT_BASS16
	IFT FEAT_BASS16
	cpy #$06		; Distortion 6?
	bne check_ch2_b		; if not equal, no BASS16
	lda tmp 		; volume value backup
	beq check_ch2_a		; if the volume is 0, no BASS16
	lda #$50		; JOIN_12 + CH1_179 bits 
	bne hellyes		; unconditional	
check_ch2_a
	lda reg1		; reload the AUDCTL, then continue like normal
	EIF
check_ch2_b
	IFT FEAT_FULL_16BIT
	bit CH1_179
	beq get_15khz_flag
	bit JOIN_12
	bne get_16bit_flag
	beq get_15khz_flag	
	ELS
	jmp get_15khz_flag
	EIF	
	ELS
	beq get_15khz_flag	; unconditional
	EIF
	
check_ch3 	
	bit CH3_179
	beq get_15khz_flag
	IFT FEAT_FULL_16BIT
	bit JOIN_34
	beq get_179_flag
	bne hellno	
	ELS
	bne get_179_flag
	EIF
	
check_ch4	
	IFT FEAT_FULL_16BIT||FEAT_BASS16
	IFT FEAT_BASS16
	cpy #$06		; Distortion 6?
	bne check_ch4_b		; if not equal, no BASS16
	lda tmp 		; volume value backup
	beq check_ch4_a		; if the volume is 0, no BASS16
	lda #$28		; JOIN_34 + CH3_179 bits 
	bne hellyes		; unconditional	
check_ch4_a
	lda reg1		; reload the AUDCTL, then continue like normal
	EIF
check_ch4_b
	IFT FEAT_FULL_16BIT
	bit CH3_179
	beq get_15khz_flag
	bit JOIN_34
	bne get_16bit_flag
	EIF
	ELS
;	beq get_15khz_flag	; unconditional	
	EIF
	
get_15khz_flag
	and #1			; #$01 == 15khz flag, unconditional 
	beq store_tables_lsb	; #$00 == 64khz flag, unconditional
check_15khz			; #$01 = 15khz flag, unconditional
	cpy #$0C		; are we in Distortion C/E?
	bcs check_15khz_b	; if equal or above, use the Distortion C 15khz table, else, use the Distortion A 15khz table
	lda #<frqtabpure_15khz	; Distortion A 15khz table LSB
	bcc check_15khz_c	; carry flag still set
check_15khz_b
	lda #<frqtabbuzzy_15khz	; Distortion C 15khz table LSB
check_15khz_c
	sta nr
	lda #>PAGE_EXTRA_0	; tables MSB pointer, it's the same one regardless of the table used
	bne store_tables_lsb_a	; unconditional 
	
	IFT FEAT_FULL_16BIT
get_16bit_flag
	lda #$80		; #$80 == Valid 16-bit flag, unconditional 
	sta nr			; 16-bit hi LSB
	lda #$C0		; 64 bytes further for the 16-bit LSB table
	sta pointer16bitlo  	; 16-bit lo LSB
	lda #0			; no volume output, Distortion won't matter
	sta trackn_audc-1,x	; process the next channel's AUDC early, no sound is wanted  
	lda TABLES_MSB,y
	sta pointer16bitlo+1	; 16-bit lo MSB
	bne store_tables_lsb_a	; unconditional, finish in the middle of the 64khz/1.79mhz branch
	EIF
	
get_179_flag
	lda #$40		; #$40 == 1.79mhz flag, unconditional 
	ELS
	
;*!!! FEAT_AUDCTLMANUALSET is not defined, so we must use some alternative code for a few things such as BASS16! 
				
	IFT FEAT_BASS16
	cpy #$06 		; Distortion 6?
	bne no_index		; channels MUST be checked, even with AUDCTL == 0, in order to process the BASS16 code properly!
	lda tmp 		; volume value backup
	beq no_index		; if the volume is 0, no BASS16
check_index
	IFT TRACKS>4		; stereo mode
	cpx #4			; are we in the right POKEY channels?
	bcc check_index_mono	; if x is lower than 4, we are not
check_index_stereo	
	cpx #7			; ch4
	beq check_ch4
	cpx #5			; ch2
	beq check_ch2	
	bne no_index		; ch1 is unconditional, the other 3 channels were already tested!
	EIF
check_index_mono
	cpx #3			; ch4
	beq check_ch4
	cpx #1			; ch2
	beq check_ch2		
	bne no_index		; ch1 is unconditional, the other 3 channels were already tested! 
check_ch4 
	lda #$28		; JOIN_34 + CH3_179 bits 
	bne hellyes		; unconditional	
check_ch2 
	lda #$50		; JOIN_12 + CH1_179 bits 
hellyes
	jmp do_bass16
	IFT FEAT_FULL_16BIT
get_16bit_flag
	lda #$80		; #$80 == Valid 16-bit flag, unconditional 
	sta nr			; 16-bit hi LSB
	lda #$C0		; 64 bytes further for the 16-bit LSB table
	sta pointer16bitlo  	; 16-bit lo LSB
	lda #0			; no volume output, Distortion won't matter
	sta trackn_audc-1,x	; process the next channel's AUDC early, no sound is wanted  
	lda TABLES_MSB,y
	sta pointer16bitlo+1	; 16-bit lo MSB
	bne store_tables_lsb_a	; unconditional, finish in the middle of the 64khz/1.79mhz branch
	EIF
	EIF			
no_index	
	lda #0			; use to overwrite the tables LSB pointer
	EIF	
			
;*!!! end of condition FEAT_AUDCTLMANUALSET
	
store_tables_lsb
	sta nr			; tables LSB pointer, divided in slices of 64 bytes each	
	lda TABLES_MSB,y
store_tables_lsb_a
	sta nr+1		; tables MSB pointer, which is the memory page used for tables divided based on their Distortion
store_tables_lsb_b
	lda tmp			; volume value backup
	ora DISTORTIONS,y	; merge the Distortion and Volume values
store_tables_lsb_c
	sta trackn_audc,x	; update the channel's AUDC for the next SetPokey subroutine call
	
;* end of tuning tables code...

;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* start of instruments effect code...
	
InstrumentsEffects
	IFT FEAT_EFFECTS
	lda trackn_effdelay,x
	beq ei2
	
; possible improvement: use CMP #2 instead? This could save a CLC instruction...
;	cmp #2			; if A >= 2 -> skip, 
;	bcs ei1			; if A < 2 -> carry flag not set, so it must be A = 1, 0 was done with beq ei2
	
	cmp #1
	bne ei1
	lda trackn_shiftfrq,x
	IFT FEAT_EFFECTFSHIFT
	clc
	adc trackn_effshift,x
	EIF
	IFT FEAT_EFFECTVIBRATO
	clc
	ldy trackn_effvibratoa,x
	adc vib0,y
	EIF
	sta trackn_shiftfrq,x
	IFT FEAT_EFFECTVIBRATO
	lda vibtabnext,y
	sta trackn_effvibratoa,x
	EIF
	jmp ei2
ei1
	dec trackn_effdelay,x
ei2
	EIF
	ldy trackn_tableend,x
	cpy #INSTRPAR+1
	bcc ei3
	lda trackn_tablespeeda,x
	bpl ei2f
ei2c
	tya
	cmp trackn_tablea,x
	bne ei2c2
	IFT FEAT_TABLEGO
	lda trackn_tablelop,x
	ELS
	lda #INSTRPAR
	EIF
	sta trackn_tablea,x
	bne ei2a
ei2c2
	inc trackn_tablea,x
ei2a
	lda trackn_instrdb,x
	sta nt
	lda trackn_instrhb,x
	sta nt+1
	ldy trackn_tablea,x
	lda (nt),y
	IFT FEAT_TABLEMODE
	ldy trackn_tablemode,x
	beq ei2e
	clc
	adc trackn_tablenote,x
ei2e
	EIF
	sta trackn_tablenote,x
	lda trackn_tabletypespeed,x
	IFT FEAT_TABLETYPE||FEAT_TABLEMODE
	and #$3f
	EIF
ei2f
	sec
	sbc #1
	sta trackn_tablespeeda,x
ei3
	lda trackn_instrreachend,x
	bpl ei4
	lda trackn_volume,x
	beq ei4
	IFT FEAT_VOLUMEMIN
	cmp trackn_volumemin,x
	beq ei4
	bcc ei4
	EIF
	tay
	lda trackn_volumeslidevalue,x
	clc
	adc trackn_volumeslidedepth,x
	sta trackn_volumeslidevalue,x
	bcc ei4
	tya
	sbc #16
	sta trackn_volume,x
ei4
	IFT FEAT_COMMAND2
	lda #0
	sta frqaddcmd2
	EIF
	IFT FEAT_COMMAND1||FEAT_COMMAND2||FEAT_COMMAND3||FEAT_COMMAND4||FEAT_COMMAND5||FEAT_COMMAND6||FEAT_COMMAND7	
	lda reg2
	and #$70
	IFT 1==[FEAT_COMMAND1+FEAT_COMMAND2+FEAT_COMMAND3+FEAT_COMMAND4+FEAT_COMMAND5+FEAT_COMMAND6+FEAT_COMMAND7]	
	beq cmd0
	ELS
	lsr @
	lsr @
	sta jmx+1
jmx	bcc *
	jmp cmd0
	nop
	jmp cmd1
	IFT FEAT_COMMAND2||FEAT_COMMAND3||FEAT_COMMAND4||FEAT_COMMAND5||FEAT_COMMAND6||FEAT_COMMAND7	
	nop
	jmp cmd2
	EIF
	IFT FEAT_COMMAND3||FEAT_COMMAND4||FEAT_COMMAND5||FEAT_COMMAND6||FEAT_COMMAND7	
	nop
	jmp cmd3
	EIF
	IFT FEAT_COMMAND4||FEAT_COMMAND5||FEAT_COMMAND6||FEAT_COMMAND7	
	nop
	jmp cmd4
	EIF
	IFT FEAT_COMMAND5||FEAT_COMMAND6||FEAT_COMMAND7	
	nop
	jmp cmd5
	EIF
	IFT FEAT_COMMAND6||FEAT_COMMAND7 
	nop
	jmp cmd6
	EIF
	IFT FEAT_COMMAND7 
	nop
	jmp cmd7
	EIF
	EIF
	EIF
	
;* end of instruments effects code...
	
;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of instruments commands code... this is a direct followup of the instruments effects code.
	
cmd1
	IFT FEAT_COMMAND1
	IFT FEAT_FULL_16BIT||FEAT_BASS16
	lda pointer16bitlo+1
	beq cmd1a		; 16-bit mode not active
	lda #0			; force the LSB channel to have empty values as a failsafe
	sta trackn_audf-1,x
	EIF
cmd1a	
	lda reg3
	jmp cmd0c
	EIF
cmd2
	IFT FEAT_COMMAND2
	lda reg3
	sta frqaddcmd2
	lda trackn_note,x
	jmp cmd0a
	EIF
cmd3
	IFT FEAT_COMMAND3
	lda trackn_note,x
	clc
	adc reg3
	sta trackn_note,x
	jmp cmd0a
	EIF
cmd4
	IFT FEAT_COMMAND4
	lda trackn_shiftfrq,x
	clc
	adc reg3
	sta trackn_shiftfrq,x
	lda trackn_note,x
	jmp cmd0a
	EIF
cmd5
	IFT FEAT_COMMAND5&&FEAT_PORTAMENTO
	IFT FEAT_TABLETYPE
	lda trackn_tabletypespeed,x
	bpl cmd5a1
	ldy trackn_note,x
	lda (nr),y
	clc
	adc trackn_tablenote,x
	jmp cmd5ax
	EIF
cmd5a1
	lda trackn_note,x
	clc
	adc trackn_tablenote,x
	cmp #61
	bcc cmd5a2
	lda #63
cmd5a2
	tay
	lda (nr),y
cmd5ax
	sta trackn_portafrqc,x
	ldy reg3
	bne cmd5a
	sta trackn_portafrqa,x
cmd5a
	tya
	lsr @
	lsr @
	lsr @
	lsr @
	sta trackn_portaspeed,x
	sta trackn_portaspeeda,x
	lda reg3
	and #$0f
	sta trackn_portadepth,x
	lda trackn_note,x
	jmp cmd0a
	ELI FEAT_COMMAND5
	lda trackn_note,x
	jmp cmd0a
	EIF
cmd6
	IFT FEAT_COMMAND6&&FEAT_FILTER	
	lda reg3
	clc
	adc trackn_filter,x
	sta trackn_filter,x
	lda trackn_note,x
	jmp cmd0a
	ELI FEAT_COMMAND6
	lda trackn_note,x
	jmp cmd0a
	EIF
	
cmd7
	IFT FEAT_COMMAND7
	IFT FEAT_TWO_TONE||FEAT_VOLUME_ONLY
	IFT FEAT_TWO_TONE
	lda reg3
	cmp #$FD		; #$FD toggles Two-Tone off
	bcc cmd7f		; no values will match if less than this, failsafe in case the BPL above didn't catch it
	beq cmd7b		; turn off the Two-Tone Filter if equal
	cmp #$FE		; #$FE toggles Two-Tone on
	beq cmd7c		; turn on the Two-Tone Filter if equal
	IFT FEAT_VOLUME_ONLY	
	bne cmd7a		; #$FF sets volume only mode, and will always be that value here, unconditional branching
	ELS
	bne cmd7f		; skip ahead, and don't set volume only mode either
	EIF
cmd7b				
	lda #3			; disable the Two-Tone Filter with this value
	bne cmd7d		; unconditional
cmd7c				
	lda #$8B		; enable the Two-Tone Filter with this value
cmd7d
	IFT TRACKS>4
	cpx #4
	bcc cmd7e		; less than 4
	sta v_skctl2		; SKCTL, Right POKEY 
	bcs cmd7f		; carry flag still set, unconditional
	EIF
cmd7e
	sta v_skctl		; SKCTL, Left POKEY
	ELS
	IFT FEAT_VOLUME_ONLY	
	lda reg3
	cmp #$FF
	beq cmd7a		; set volume only mode if equal
	EIF
	EIF
cmd7f
	lda trackn_note,x	; this is the expected variable in memory
	jmp cmd0a 
cmd7a
	IFT FEAT_VOLUME_ONLY
	lda trackn_audc,x
	ora #$f0
	sta trackn_audc,x
	bne cmd7f		; unconditional
	EIF
	ELS
	lda trackn_note,x	; this is the expected variable in memory
	jmp cmd0a 
	EIF
	EIF
	
cmd0
	lda trackn_note,x
	clc
	adc reg3
cmd0a
	IFT FEAT_TABLETYPE
	ldy trackn_tabletypespeed,x
	bmi cmd0b
	EIF
	clc
	adc trackn_tablenote,x
	cmp #61
	bcc cmd0a1
	lda #0
	sta trackn_audc,x
	lda #63
cmd0a1
	tay
	
cmd0a1_a
	IFT FEAT_FULL_16BIT||FEAT_BASS16
	lda pointer16bitlo+1
	beq cmd0a2		; 16-bit mode not active
	lda (nr),y
	sta trackn_audf,x	; get and store the MSB early
	lda trackn_shiftfrq,x
	IFT FEAT_COMMAND2
	clc
	adc frqaddcmd2
	EIF
	sta tmp			; get and store the frequency shift early, combined if CMD2 is also enabled
	bmi cmd0a1sub		; will subtract 1 from the MSB if negative on overflow
cmd0a1add
	lda (pointer16bitlo),y
	clc
	adc tmp
	sta trackn_audf-1,x	; LSB 16-bit channel, update early here
	bcc cmd0a1adddone	; no overflow, done
	inc trackn_audf,x	; increment the MSB if the value went past #$FF
cmd0a1adddone	
	jmp pp9			; done
cmd0a1sub
	lda (pointer16bitlo),y
	clc
	adc tmp
	sta trackn_audf-1,x	; LSB 16-bit channel, update early here
	bcs cmd0a1adddone	; no overflow, done
	dec trackn_audf,x	; decrement the MSB if the value went past #$00
cmd0a1subdone	
	jmp pp9			; done
	EIF
	
cmd0a2	
	IFT FEAT_FULL_SAWTOOTH
	lda sawtoothtables+1
	beq cmd0a3		; sawtooth not active
	lda (sawtoothtables),y
	clc
	adc trackn_shiftfrq,x
	IFT FEAT_COMMAND2
	clc
	adc frqaddcmd2
	EIF	
	sta trackn_audf+2,x	; since we're in channel 1 of either POKEY, offset +2 will always be the 3rd channel
	EIF

cmd0a3
	lda (nr),y
	clc
	adc trackn_shiftfrq,x
	IFT FEAT_COMMAND2
	clc
	adc frqaddcmd2
	EIF
	
	IFT FEAT_TABLETYPE
	jmp cmd0c
cmd0b
	cmp #61
	bcc cmd0b1
	lda #0
	sta trackn_audc,x
	lda #63
cmd0b1
	tay

cmd0b1_a
	IFT FEAT_FULL_16BIT||FEAT_BASS16
	lda pointer16bitlo+1
	beq cmd0b2		; 16-bit mode not active
	lda (nr),y
	sta trackn_audf,x	; get and store the MSB early
	lda trackn_shiftfrq,x
	clc
	adc trackn_tablenote,x
	clc	
	IFT FEAT_COMMAND2
	clc
	adc frqaddcmd2
	EIF
	sta tmp			; get and store the frequency shift early, combined if CMD2 is also enabled
	bmi cmd0b1sub		; will subtract 1 from the MSB if negative on overflow
cmd0b1add
	lda (pointer16bitlo),y
	clc
	adc tmp
	sta trackn_audf-1,x	; LSB 16-bit channel, update early here
	bcc cmd0b1adddone	; no overflow, done
	inc trackn_audf,x	; increment the MSB if the value went past #$FF
cmd0b1adddone	
	jmp pp9			; done
cmd0b1sub
	lda (pointer16bitlo),y
	clc
	adc tmp
	sta trackn_audf-1,x	; LSB 16-bit channel, update early here
	bcs cmd0b1adddone	; no overflow, done
	dec trackn_audf,x	; decrement the MSB if the value went past #$00
cmd0b1subdone	
	jmp pp9			; done
	EIF
	
cmd0b2	
	IFT FEAT_FULL_SAWTOOTH 
	lda sawtoothtables+1
	beq cmd0b3		; sawtooth not active
	lda trackn_shiftfrq,x
	clc
	adc trackn_tablenote,x
	clc
	adc (sawtoothtables),y
	IFT FEAT_COMMAND2
	clc
	adc frqaddcmd2
	EIF	
	sta trackn_audf+2,x	; since we're in channel 1 of either POKEY, offset +2 will always be the 3rd channel
	EIF

cmd0b3
	lda trackn_shiftfrq,x
	clc
	adc trackn_tablenote,x
	clc
	adc (nr),y
	IFT FEAT_COMMAND2
	clc
	adc frqaddcmd2
	EIF
	EIF
	
cmd0c
	sta trackn_audf,x
	
;* end of instruments commands code... 
	
;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* start of Portamento code... This is currently not properly compatible with 16-bit mode or Sawtooth, unfortunately.
	
pp9
	IFT FEAT_PORTAMENTO
	lda trackn_portaspeeda,x
	beq pp10
	dec trackn_portaspeeda,x
	bne pp10
	lda trackn_portaspeed,x
	sta trackn_portaspeeda,x
	lda trackn_portafrqa,x
	cmp trackn_portafrqc,x
	beq pp10
	bcs pps1
	adc trackn_portadepth,x
	bcs pps8
	cmp trackn_portafrqc,x
	bcs pps8
	jmp pps9
pps1
	sbc trackn_portadepth,x
	bcc pps8
	cmp trackn_portafrqc,x
	bcs pps9
pps8
	lda trackn_portafrqc,x
pps9
	sta trackn_portafrqa,x
pp10
	lda reg2
	and #$01
	beq pp11
	lda trackn_portafrqa,x
	clc
	adc trackn_shiftfrq,x	
pp10a	
	sta trackn_audf,x
pp11
	EIF

;* end of Portamento code...

;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* part of mainloop code... this is an extra step added for the purpose of clearning the memory from 16-bit or Sawtooth addresses when unused.

	IFT FEAT_FULL_SAWTOOTH||FEAT_FULL_16BIT||FEAT_BASS16
	ldy #0			; reset the values to 0, since they're no longer needed for checks
	IFT FEAT_FULL_SAWTOOTH
	sty sawtoothtables
	sty sawtoothtables+1
	EIF
pp11a
	IFT FEAT_FULL_16BIT||FEAT_BASS16
	lda pointer16bitlo+1
	beq ppnext		; 16-bit mode not active, no overwrite
	sty pointer16bitlo
	sty pointer16bitlo+1
	dex			;* skip the next channel since it was updated early!!
	EIF
	EIF
	
ppnext
	dex
	bmi rmt_p4
	jmp pp1
rmt_p4

;* end of mainloop code... everything below will be conditionally assembled for easy optimisation.
	
;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of Autofilter code... a much more stripped down version

	IFT FEAT_FILTER
	ldx v_audctl 
qq1
	IFT FEAT_FILTERG0L
	lda trackn_command+0
	bpl qq2
	lda trackn_audc+0
	and #$0f
	beq qq2
	lda trackn_audf+0
	clc
	adc trackn_filter+0
	sta trackn_audf+2
qq1a
	txa
	ora #4
	tax
	EIF
qq2
	IFT FEAT_FILTERG1L
	lda trackn_command+1
	bpl qq3
	lda trackn_audc+1
	and #$0f
	beq qq3
	lda trackn_audf+1
	clc
	adc trackn_filter+1
	sta trackn_audf+3
qq2a
	txa
	ora #2
	tax
	EIF
qq3
	stx v_audctl
	EIF
	
	IFT FEAT_FILTER&&TRACKS>4
	ldx v_audctl2 
	IFT FEAT_FILTERG0R
	lda trackn_command+0+4
	bpl qs2
	lda trackn_audc+0+4
	and #$0f
	beq qs2
	lda trackn_audf+0+4
	clc
	adc trackn_filter+0+4
	sta trackn_audf+2+4
qs1a
	txa
	ora #4
	tax
	EIF
qs2
	IFT FEAT_FILTERG1R
	lda trackn_command+1+4
	bpl qs3
	lda trackn_audc+1+4
	and #$0f
	beq qs3
	lda trackn_audf+1+4
	clc
	adc trackn_filter+1+4
	sta trackn_audf+3+4
qs2a
	txa
	ora #2
	tax
	EIF
qs3
	stx v_audctl2
	EIF
	
;* end of Autofilter code...

;---------------------------------------------------------------------------------------------------------------------------------------------;	
	
;* end of mainloop code, hit that RTS and that's it!
	
rmt_p5	
	rts 

;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of Sawtooth code...

	IFT FEAT_FULL_SAWTOOTH
do_sawtooth
	lda reg2
	bpl hijack_sawtooth_done	; AUTOFILTER command is off, skip overwriting the other things	
	IFT FEAT_FILTER
	eor #$80			; inverts the AUTOFILTER bit, so it does not overwrite things later
	sta trackn_command,x		; overwrite the command byte before the AUTOFILTER code since things where done early
	EIF
	lda #4				; high pass filter, CH1+3
	IFT TRACKS>4			; stereo mode
	cpx #4				; are we in the right POKEY channels?
	bcc sawtooth_audctl_mono	; if x is lower than 4, we are not
	ora v_audctl2			; combine the existing AUDCTL value to it
	sta v_audctl2			; store the new AUDCTL value, right POKEY
	bne sawtooth_audctl_done	; unconditional
	EIF
sawtooth_audctl_mono	
	ora reg1			; combine the existing AUDCTL value to it
	sta v_audctl			; store the new AUDCTL value, left POKEY
sawtooth_audctl_done
	IFT FEAT_COMMAND6		; Sawtooth CMD6 hack... could be optimised much better, or maybe moved into the commands? 
	lda reg2			; Command and Distortion
	and #$70			; keep the Command bits only
	cmp #$60			; CMD6?
	bne hijack_sawtooth_done	; skip if not equal
	lda reg3			; $XY parameter
	beq hijack_sawtooth_done	; skip if the value is 0, nothing will be changed
	bmi sawtooth_reverse		; negative values (#$80 to #$FF) will reverse the pointers, positive values (#$01 to #$7F) will set the pointers back to normal
sawtooth_normal
	lda #<frqtabsawtooth_ch1
	sta saw_ch1
	lda #<frqtabsawtooth_ch3
	sta saw_ch3	
	bpl hijack_sawtooth_done
sawtooth_reverse
	lda #<frqtabsawtooth_ch3
	sta saw_ch1
	lda #<frqtabsawtooth_ch1
	sta saw_ch3	
	EIF
hijack_sawtooth_done
	lda #<frqtabsawtooth_ch1
saw_ch1	equ *-1	
	sta nr 
	lda #<frqtabsawtooth_ch3
saw_ch3	equ *-1	
	sta sawtoothtables
hijack_sawtooth_done_a
	lda #>PAGE_EXTRA_0		; tables MSB pointer, it's the same one regardless of the table used
	sta sawtoothtables+1		; for the other channel later, also used as a check if it is enabled	
	jmp store_tables_lsb_a		; finish in the middle of the 64khz/1.79mhz branch
	EIF

;* end of Sawtooth code...

;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* start of BASS16 code...

	IFT FEAT_BASS16	
do_bass16 
	IFT TRACKS>4		; stereo mode
	cpx #4			; are we in the right POKEY channels?
	bcc do_bass16_a 	; if x is lower than 4, we are not
	ora v_audctl2		; merge the values with the AUDCTL in memory
	sta v_audctl2		; overwrite the AUDCTL, to force 16-bit mode through Distortion 6
	bne do_bass16_b		; unconditional	
	EIF
do_bass16_a
	ora v_audctl		; merge the values with the AUDCTL in memory
	sta v_audctl		; overwrite the AUDCTL, to force 16-bit mode through Distortion 6
do_bass16_b
	IFT FEAT_COMMAND6&&FEAT_FULL_16BIT
	lda reg2		; Distortion and Commands
	and #$70		; leave only the Commands bits
	cmp #$60		; CMD6?
	bne do_bass16_c		; skip if not CMD6
	lda reg3		; XY parameter 
	and #$0E		; strip away all unwanted bits, left nybble will not affect anything
	sta bass16_pointer	; PERMANENTLY change the value until a new CMD6 value is read
	EIF
	IFT FEAT_FULL_16BIT	
do_bass16_c
	ldy #$0A		; Distortion A
bass16_pointer equ *-1 
	jmp get_16bit_flag	; process the remaining of the 16-bit code from there
	ELS
	lda #<frqtabpure_hi
	sta nr
	lda #<frqtabpure_lo
	sta pointer16bitlo 	
	lda #0				
	sta trackn_audc-1,x	; update the next channel's AUDC early, it will always be volume 0, and Distortion won't matter
	lda #>PAGE_DISTORTION_A
	sta pointer16bitlo+1	; this value can also be used to identify if 16-bit mode is active or not, since it will never be 0
	sta nr+1
	lda tmp
	ora #$A0
	jmp store_tables_lsb_c
	EIF
	EIF

;* end of BASS16 code...

;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* start of the SetPokey routines...

SetPokey
	ldy #0
v_audctl equ *-1			; left POKEY AUDCTL is loaded as the very first thing, for all STEREOMODE variations
	IFT STEREOMODE==1		;* L1 L2 L3 L4 R1 R2 R3 R4
	lda trackn_audf+0+4
	ldx trackn_audf+0
	sta $d210
	stx $d200
	lda trackn_audc+0+4
	ldx trackn_audc+0
	sta $d211
	stx $d201
	lda trackn_audf+1+4
	ldx trackn_audf+1
	sta $d212
	stx $d202
	lda trackn_audc+1+4
	ldx trackn_audc+1
	sta $d213
	stx $d203
	lda trackn_audf+2+4
	ldx trackn_audf+2
	sta $d214
	stx $d204
	lda trackn_audc+2+4
	ldx trackn_audc+2
	sta $d215
	stx $d205
	lda trackn_audf+3+4
	ldx trackn_audf+3
	sta $d216
	stx $d206
	lda trackn_audc+3+4
	ldx trackn_audc+3
	sta $d217
	stx $d207
	lda #0
v_audctl2 equ *-1
	sty $d208
	sta $d218
	IFT FEAT_TWO_TONE
	lda #$03
v_skctl equ *-1	
	ldy #$03
v_skctl2 equ *-1
	sta $d20f	
	sty $d21f		
	EIF
	ELI STEREOMODE==0		;* L1 L2 L3 L4
	lda trackn_audf+0
	ldx trackn_audc+0
	sta $d200
	stx $d201
	lda trackn_audf+1
	ldx trackn_audc+1
	sta $d200+2
	stx $d201+2
	lda trackn_audf+2
	ldx trackn_audc+2
	sta $d200+4
	stx $d201+4
	lda trackn_audf+3
	ldx trackn_audc+3
	sta $d200+6
	stx $d201+6
	sty $d208
	IFT FEAT_TWO_TONE
	lda #$03
v_skctl equ *-1	
	sta $d20f
	EIF	
	ELI STEREOMODE==2		;* L1 R2 R3 L4
	lda trackn_audf+0
	ldx trackn_audc+0
	sta $d200
	stx $d201
	sta $d210
	lda trackn_audf+1
	ldx trackn_audc+1
	sta $d210+2
	stx $d211+2
	lda trackn_audf+2
	ldx trackn_audc+2
	sta $d210+4
	stx $d211+4
	sta $d200+4
	lda trackn_audf+3
	ldx trackn_audc+3
	sta $d200+6
	stx $d201+6
	sta $d210+6
	sty $d218
	sty $d208
	IFT FEAT_TWO_TONE
	lda #$03
v_skctl equ *-1	
	sta $d20f
	sta $d21f
	EIF
	ELI STEREOMODE==3		;* L1 L2 R3 R4
	lda trackn_audf+0
	ldx trackn_audc+0
	sta $d200
	stx $d201
	lda trackn_audf+1
	ldx trackn_audc+1
	sta $d200+2
	stx $d201+2
	lda trackn_audf+2
	ldx trackn_audc+2
	sta $d210+4
	stx $d211+4
	sta $d200+4
	lda trackn_audf+3
	ldx trackn_audc+3
	sta $d210+6
	stx $d211+6
	sta $d200+6
	sty $d218
	sty $d208
	IFT FEAT_TWO_TONE
	lda #$03
v_skctl equ *-1	
	sta $d20f
	sta $d21f
	EIF
	EIF
	rts
	
;* end of SetPokey routines...
	
;---------------------------------------------------------------------------------------------------------------------------------------------;
	
RMTPLAYEREND
	
;* Player ends here, what lies after is anything you want, and the extra workaround code if assembled as a 'tracker.obx' binary	

;---------------------------------------------------------------------------------------------------------------------------------------------;

;* Let's not forget the tables and other RMT data! 
	icl "rmtdata.a65"
	
;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* The workaround code is mandatory in order to avoid many things breaking in RMT!
	IFT FEAT_IS_TRACKER
	icl "rmtextra.a65" 
	EIF

;---------------------------------------------------------------------------------------------------------------------------------------------;

;* And that's all folks :D

