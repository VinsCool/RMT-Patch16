;*
;* Raster Music Tracker, RMT Atari routine version Patch16-3.2
;* (c) Radek Sterba, Raster/C.P.U., 2002 - 2009
;* http://raster.atari.org
;*
;* Unofficial version by VinsCool, 2021 - 2022
;* https://github.com/VinsCool/RMT-Patch16
;*
;* TO DO: A lot... So much to re-order and cleanup...
;* I must recalculate everything, once the full code cleanup and optimisation is done.
;* Currently, all infos are incorrect due to the massive amount of changes I have done into the code.
;* I apologise for the inconvenience, I am doing my best to clean everything to make sense again.
;*

;---------------------------------------------------------------------------------------------------------------------------------------------;

;* RMT FEATures definitions file
	icl "rmt_feat.a65"
	
;* For optimizations of RMT player routine to concrete RMT module only!

;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of RMT definitions...

	IFT STEREOMODE==1
TRACKS			equ 8
	ELS
TRACKS			equ 4
	EIF
	
PLAYER			equ $3400
TABLES			equ $B000
INSTRPAR		equ 12

;* RMT ZeroPage addresses
	org 203	     	;* org $CB
	
p_tis
p_instrstable		org *+2
p_trackslbstable	org *+2
p_trackshbstable	org *+2
p_song			org *+2
ns			org *+2
nr			org *+2
nt			org *+2
reg1			org *+1
reg2			org *+1
reg3			org *+1
tmp			org *+1

	IFT FEAT_COMMAND2
frqaddcmd2		org *+1
	EIF

; these 2 pointer hijacking pieces could be implemented better...

	IFT FEAT_FULL_16BIT||FEAT_BASS16
pointer16bitlo		org *+2
	EIF
	
	IFT FEAT_FULL_SAWTOOTH
sawtoothtables		org *+2
	EIF 
	
;* possible improvement: setting variables after the RMT driver itself? 
;* That would make adjustments easier to manage, if this works as I expect...

	IFT TRACKS>4			
	org PLAYER-$400+$40
	ELS
	org PLAYER-$400+$e0
	EIF
	
track_variables

trackn_db		org *+TRACKS
trackn_hb		org *+TRACKS
trackn_idx		org *+TRACKS
trackn_pause		org *+TRACKS
trackn_note		org *+TRACKS
trackn_volume		org *+TRACKS
trackn_volumeenvelope	org *+TRACKS
trackn_command		org *+TRACKS
trackn_effectparameter	org *+TRACKS
trackn_shiftfrq		org *+TRACKS

	IFT FEAT_PORTAMENTO
trackn_portafrqc 	org *+TRACKS
trackn_portafrqa 	org *+TRACKS
trackn_portaspeed 	org *+TRACKS
trackn_portaspeeda 	org *+TRACKS
trackn_portadepth 	org *+TRACKS
	EIF
	
trackn_instrx2		org *+TRACKS
trackn_instrdb		org *+TRACKS
trackn_instrhb		org *+TRACKS
trackn_instridx		org *+TRACKS
trackn_instrlen		org *+TRACKS
trackn_instrlop		org *+TRACKS
trackn_instrreachend	org *+TRACKS
trackn_volumeslidedepth org *+TRACKS
trackn_volumeslidevalue org *+TRACKS

	IFT FEAT_VOLUMEMIN
trackn_volumemin	org *+TRACKS
	EIF
	
FEAT_EFFECTS equ FEAT_EFFECTVIBRATO||FEAT_EFFECTFSHIFT
	IFT FEAT_EFFECTS
trackn_effdelay		org *+TRACKS
	EIF
	
	IFT FEAT_EFFECTVIBRATO
trackn_effvibratoa	org *+TRACKS
	EIF
	
	IFT FEAT_EFFECTFSHIFT
trackn_effshift		org *+TRACKS
	EIF
	
trackn_tabletypespeed 	org *+TRACKS

	IFT FEAT_TABLEMODE
trackn_tablemode	org *+TRACKS
	EIF
	
trackn_tablenote	org *+TRACKS
trackn_tablea		org *+TRACKS
trackn_tableend		org *+TRACKS

	IFT FEAT_TABLEGO
trackn_tablelop		org *+TRACKS
	EIF
	
trackn_tablespeeda	org *+TRACKS

	IFT FEAT_FILTER
trackn_filter		org *+TRACKS		;* POTENTIAL OPTIMISATION: it is NOT necessary to use all tracks... only channel 1 and 2 will use it to offset the other...
	EIF
	
	IFT FEAT_TABLE_MANUAL
trackn_pointertable	org *+TRACKS	
	EIF
	
	IFT FEAT_AGGRESSIVE_INIT
trackn_flags		org *+TRACKS
	EIF
	
	IFT FEAT_AUDCTLMANUALSET
trackn_audctl		org *+TRACKS
	EIF	
	
trackn_audf		org *+TRACKS
trackn_audc		org *+TRACKS

v_aspeed		org *+1

track_endvariables

;* end of RMT definitions...
	
;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of RMT data... maybe this could be moved elsewhere, much like the tuning tables?
	
	org PLAYER-$0200	; I need to improve the label organisation here as well, also do I really need to org there? my memory is hazy, why did even do this...?
	
	IFT FEAT_AUDCTLMANUALSET
AUDCTLBITS	; bits to test for AUDCTL lookup tables
POLY9	dta $80	; bit 7
CH1_179	dta $40	; bit 6
CH3_179	dta $20	; bit 5
JOIN_12	dta $10	; bit 4
JOIN_34	dta $08	; bit 3
HPF_CH1	dta $04	; bit 2
HPF_CH2	dta $02	; bit 1
CLOCK15	dta $01	; bit 0
	EIF	
	
	IFT FEAT_FULL_TABLES_HIJACK
TABLES_MSB
DISTORTIONS equ *+1
	dta >PAGE_DISTORTION_A,$00
	dta >PAGE_DISTORTION_2,$20
	dta >PAGE_DISTORTION_A,$40
	dta >PAGE_DISTORTION_A,$A0
	dta >PAGE_DISTORTION_A,$80
	dta >PAGE_DISTORTION_A,$A0
	dta >PAGE_DISTORTION_C,$C0
	dta >PAGE_DISTORTION_E,$C0
	EIF
	
	IFT FEAT_EFFECTVIBRATO
vibtabbeg 
	dta 0,vib1-vib0,vib2-vib0,vib3-vib0
vib0	dta 0
vib1	dta 1,-1,-1,1
vib2	dta 1,0,-1,-1,0,1
vib3	dta 1,1,0,-1,-1,-1,-1,0,1,1
vibtabnext
	dta vib0-vib0+0
	dta vib1-vib0+1,vib1-vib0+2,vib1-vib0+3,vib1-vib0+0
	dta vib2-vib0+1,vib2-vib0+2,vib2-vib0+3,vib2-vib0+4,vib2-vib0+5,vib2-vib0+0
	dta vib3-vib0+1,vib3-vib0+2,vib3-vib0+3,vib3-vib0+4,vib3-vib0+5,vib3-vib0+6,vib3-vib0+7,vib3-vib0+8,vib3-vib0+9,vib3-vib0+0
	EIF	
	
	org PLAYER-$0100	;* it may be possible to reduce this table by half the size it is... this was something I did for the older RMT Patch16 code, so the option is still valuable...
volumetab
	dta $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
	dta $00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
	dta $00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01,$02,$02,$02,$02
	dta $00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02,$03,$03,$03
	dta $00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03,$04,$04
	dta $00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
	dta $00,$00,$01,$01,$02,$02,$02,$03,$03,$04,$04,$04,$05,$05,$06,$06
	dta $00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
	dta $00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07,$08
	dta $00,$01,$01,$02,$02,$03,$04,$04,$05,$05,$06,$07,$07,$08,$08,$09
	dta $00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$07,$07,$08,$09,$09,$0A
	dta $00,$01,$01,$02,$03,$04,$04,$05,$06,$07,$07,$08,$09,$0A,$0A,$0B
	dta $00,$01,$02,$02,$03,$04,$05,$06,$06,$07,$08,$09,$0A,$0A,$0B,$0C
	dta $00,$01,$02,$03,$03,$04,$05,$06,$07,$08,$09,$0A,$0A,$0B,$0C,$0D
	dta $00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0A,$0B,$0C,$0D,$0E
	dta $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F

;* end of RMT data...
	
;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of RMT jump table...

        org PLAYER			;* Possible improvement: give proper labels to each JMPs below... to avoid confusion, and also make things easier to map in memory, unless the destination is being JSR'ed directly...

RASTERMUSICTRACKER
	jmp rmt_init			;* Must be run first, to clear memory and initialise the player... Once this is done, run rmt_play afterwards, or Set_Pokey if you want to manually time certain things.
	jmp rmt_play			;* One play each subroutine call. SetPokey is executed first, then all the play code is ran once, until the RTS. rmt_play could be called multiple times per frame if wanted.
	jmp rmt_p3			;* Similar to rmt_play, but will also skip SetPokey and the instruments/songlines/tracklines initialisation, very useful for playing simple things.
	jmp rmt_silence			;* Run this to stop the driver, and reset all POKEY registers to 0. This is also part of rmt_init when it is executed first.
	jmp SetPokey			;* Run to copy the contents of the Shadow POKEY registers (v_audctl, v_skctl, trackn_audf,x etc) into the real ones. Will be run first each time rmt_play is called.
	IFT FEAT_SFX
	jmp rmt_sfx			;* A=note(0,..,60),X=channel(0,..,3 or 0,..,7),Y=instrument*2(0,2,4,..,126)
	EIF
	
;* end of RMT jump table... from here, all the main driver code is being executed, have fun playing around! ;)
	
;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of rmt_init code...
	
rmt_init
	stx ns
	sty ns+1
	IFT FEAT_NOSTARTINGSONGLINE==0
	pha	; backup the song line into the stack for now... I wonder if I could just use tmp in zeropage instead...
	EIF
		
	IFT track_endvariables-track_variables>255	; more than 255 variables in memory...
	ldy #0
	tya
ri0	
	sta track_variables,y
	sta track_endvariables-$100,y
	iny
	bne ri0
	
	ELS						
	ldy #track_endvariables-track_variables
	lda #0
ri0	
	sta track_variables-1,y
	dey
	bne ri0
	EIF
	
	ldy #4
	lda (ns),y
	sta v_maxtracklen
	iny
	IFT FEAT_CONSTANTSPEED==0
	lda (ns),y
	sta v_speed
	EIF
	IFT FEAT_INSTRSPEED==0
	iny
	lda (ns),y
	sta v_instrspeed
	sta v_ainstrspeed
	ELI FEAT_INSTRSPEED>1
	lda #FEAT_INSTRSPEED
	sta v_ainstrspeed
	EIF
	ldy #8
ri1	
	lda (ns),y
	sta p_tis-8,y
	iny
	cpy #8+8
	bne ri1
	IFT FEAT_NOSTARTINGSONGLINE==0
	pla
	pha
	IFT TRACKS>4
	asl @
	asl @
	asl @
	clc
	adc p_song
	sta p_song
	pla
	php
	and #$e0
	asl @
	rol @
	rol @
	rol @
	ELS
	asl @
	asl @
	clc
	adc p_song
	sta p_song
	pla
	php
	and #$c0
	asl @
	rol @
	rol @
	EIF
	plp
	adc p_song+1
	sta p_song+1
	EIF
	jsr GetSongLineTrackLineInitOfNewSetInstrumentsOnlyRmtp3
	
;* end of rmt_init code... rmt_silence will always be executed after the JSR above.
	
;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* start of rmt_silence code...
	
rmt_silence
	IFT STEREOMODE>0
	lda #0
	sta $d208
	sta $d218
	ldy #3
	sty $d20f
	sty $d21f
	IFT FEAT_TWO_TONE&&FEAT_IS_TRACKER	;* potential improvement: setting this elsewhere so the first frame of play would not be overwritten if defined early
	sty v_skctl
	sty v_skctl2
	EIF
	ldy #8
si1	
	sta $d200,y
	sta $d210,y
	dey
	bpl si1
	ELS
	lda #0
	sta $d208
	ldy #3
	sty $d20f
	IFT FEAT_TWO_TONE&&FEAT_IS_TRACKER	;* potential improvement: setting this elsewhere so the first frame of play would not be overwritten if defined early
	sty v_skctl 
	EIF
	ldy #8
si1	
	sta $d200,y	
	dey
	bpl si1
	EIF
	
	IFT FEAT_IS_TRACKER&&FEAT_FULL_SAWTOOTH&&FEAT_FULL_TABLES_HIJACK&&FEAT_AGGRESSIVE_INIT	
	lda #<frqtabsawtooth_ch1	; reset the sawtooth pointers
	sta saw_ch1
	lda #<frqtabsawtooth_ch3
	sta saw_ch3		
	EIF
	IFT FEAT_IS_TRACKER&&FEAT_FULL_16BIT&&FEAT_BASS16&&FEAT_FULL_TABLES_HIJACK&&FEAT_AGGRESSIVE_INIT 
	lda #$0A			
	sta bass16_pointer		; PERMANENTLY change the value until a new CMD6 value is read
	EIF	

	IFT FEAT_INSTRSPEED==0
	lda #$ff
v_ainstrspeed equ *-1			; return instrument speed, does not seem to matter after rmt_init?
	ELS
	lda #FEAT_INSTRSPEED
	EIF
	rts
	
;* end of rmt_silence code...
	
;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* start of mainloop code here... most of it is related to the songlines, tracklines and instruments initialisation...
	
GetSongLineTrackLineInitOfNewSetInstrumentsOnlyRmtp3
GetSongLine
	ldx #0
	stx v_abeat			; set the pattern row to 0 for the new songline... This could be exploited with an effect command related to premature pattern end, or pattern goto...
	
nn0
nn0_a
        IFT FEAT_IS_VISUALP		; RMT Visualiser hack for displaying the songline number, this is 100% useless but cool to have nonetheless.
	lda p_song
	sub MODUL+14 
	sta v_ord			; this variable only exists in rmtvis, this is what will be used to display the songline number
	lda p_song+1
	sbc MODUL+15
	lsr @
	ror v_ord
	lsr @
	ror v_ord
	IFT TRACKS>4
	lsr @
	ror v_ord
	EIF
	EIF
nn0_b
	IFT FEAT_IS_SIMPLEP
	IFT EXPORTXEX			; Simple RMT Player hack for colour cycling, change the rasterbar colour every new pattern played
	lda loop+1			; the #RASTERBAR colour defined will be loaded there specifically
	add #16				; offset the value by #$10 for a simple colour shuffle
	sta loop+1   			; store back where it was loaded, overwriting the previous value
	EIF 
	EIF
	
nn1	
	txa
	tay
	lda (p_song),y
	cmp #$fe			; #$FE = Goto songline, #$FF = Empty track
	bcs nn2				; branch if greater or equal
	tay
	lda (p_trackslbstable),y
	sta trackn_db,x
	lda (p_trackshbstable),y
nn1a 	
	sta trackn_hb,x
	lda #0
	sta trackn_idx,x
	lda #1
nn1a2 	
	sta trackn_pause,x		; #1 is a new note, #0 is no new note
	lda #$80
	sta trackn_instrx2,x		; #$80 is negative, will BMI when encountered, meaning no new instrument initialisation
	inx	
	cpx #TRACKS
	bne nn1
	lda p_song
	clc	
	adc #TRACKS
	sta p_song
	bcc GetTrackLine
	inc p_song+1
	
nn1b
	jmp GetTrackLine
nn2
	beq nn3				; branch if equal to #$FE, this is a Goto songline command
nn2a
	lda #0				; used to set the instrument to 0, meaning no new note
	beq nn1a2			; unconditional
nn3
	ldy #2
	lda (p_song),y
	tax
	iny
	lda (p_song),y
	sta p_song+1
	stx p_song
	ldx #0
	beq nn0
	
GetTrackLine
oo0
oo0a
	IFT FEAT_CONSTANTSPEED==0
	lda #$ff
v_speed equ *-1
	sta v_bspeed
	EIF
	ldx #-1
oo1
	inx
	dec trackn_pause,x
	bne oo1x
oo1b
	lda trackn_db,x
	sta ns
	lda trackn_hb,x
	sta ns+1
oo1i
	ldy trackn_idx,x
	inc trackn_idx,x
	lda (ns),y
	sta reg1
	and #$3f
	cmp #61
	beq oo1a
	bcs oo2
	sta trackn_note,x
	iny
	lda (ns),y
	lsr @
	and #$3f*2
	sta trackn_instrx2,x
oo1a
	lda #1
	sta trackn_pause,x
	ldy trackn_idx,x
	inc trackn_idx,x
	lda (ns),y
	lsr @
	ror reg1
	lsr @
	ror reg1
	lda reg1
	IFT FEAT_GLOBALVOLUMEFADE
	sec
	sbc #$00
RMTGLOBALVOLUMEFADE equ *-1
	bcs voig
	lda #0
voig
	EIF
	and #$f0
	sta trackn_volume,x
oo1x	
	cpx #TRACKS-1
	bne oo1
	IFT FEAT_CONSTANTSPEED==0
	lda #$ff
v_bspeed equ *-1
	sta v_speed
	ELS
	lda #FEAT_CONSTANTSPEED
	EIF
	sta v_aspeed
	jmp InitOfNewSetInstrumentsOnly
	
oo2
	cmp #63
	beq oo63
	lda reg1
	and #$c0
	beq oo62_b
	asl @
	rol @
	rol @
	sta trackn_pause,x
	jmp oo1x
oo62_b
	iny
	lda (ns),y
	sta trackn_pause,x
	inc trackn_idx,x
	jmp oo1x
oo63
	lda reg1
	IFT FEAT_CONSTANTSPEED==0
	bmi oo63_1X
	iny
	lda (ns),y
	sta v_bspeed
	inc trackn_idx,x
	jmp oo1i
oo63_1X
	EIF
	cmp #255
	beq oo63_11
	iny
	lda (ns),y
	sta trackn_idx,x
	jmp oo1i
oo63_11
	jmp GetSongLine
	
p2xrmtp3	
	jmp rmt_p3
p2x0 	
	dex
	bmi p2xrmtp3
	
InitOfNewSetInstrumentsOnly
p2x1 	
	ldy trackn_instrx2,x
	bmi p2x0		; if negative, there is no new instrument to initialise for this channel
	
;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of RMT_SFX code...
	
	IFT FEAT_SFX
	jsr SetUpInstrumentY2
	jmp p2x0
rmt_sfx
	sta trackn_note,x
	lda #$f0		;* sfx note volume*16
RMTSFXVOLUME equ *-1		;* label for sfx note volume parameter overwriting
	sta trackn_volume,x
	EIF
	
;* end of RMT_SFX code...

;---------------------------------------------------------------------------------------------------------------------------------------------;
	
SetUpInstrumentY2
	lda (p_instrstable),y
	sta trackn_instrdb,x
	sta nt
	iny
	lda (p_instrstable),y
	sta trackn_instrhb,x
	sta nt+1
	IFT FEAT_FILTER
	lda #1
	sta trackn_filter,x
	EIF
	IFT FEAT_TABLEGO
	IFT FEAT_FILTER
	tay
	ELS
	ldy #1
	EIF
	lda (nt),y
	sta trackn_tablelop,x
	iny
	ELS
	ldy #2
	EIF
	lda (nt),y
	sta trackn_instrlen,x
	iny
	lda (nt),y
	sta trackn_instrlop,x
	iny
	lda (nt),y
	sta trackn_tabletypespeed,x
	IFT FEAT_TABLETYPE||FEAT_TABLEMODE
	and #$3f
	EIF
	sta trackn_tablespeeda,x
	IFT FEAT_TABLEMODE
	lda (nt),y
	and #$40
	sta trackn_tablemode,x
	EIF
	IFT FEAT_AUDCTLMANUALSET
	iny
	lda (nt),y
	sta trackn_audctl,x
	iny
	ELS
	ldy #6
	EIF
	lda (nt),y
	sta trackn_volumeslidedepth,x
	IFT FEAT_VOLUMEMIN
	iny
	lda (nt),y
	sta trackn_volumemin,x
	IFT FEAT_EFFECTS
	iny
	EIF
	ELS
	IFT FEAT_EFFECTS
	ldy #8
	EIF
	EIF
	IFT FEAT_EFFECTS
	lda (nt),y
	sta trackn_effdelay,x
	IFT FEAT_EFFECTVIBRATO
	iny
	lda (nt),y
	tay
	lda vibtabbeg,y
	sta trackn_effvibratoa,x
	EIF
	IFT FEAT_EFFECTFSHIFT
	ldy #10
	lda (nt),y
	sta trackn_effshift,x
	EIF
	EIF
	IFT FEAT_TABLE_MANUAL	; Manual tuning table loaded from instruments, based on the unused 12th byte, this is not yet fully implemented into RMT
	ldy #11
	lda (nt),y
	sta trackn_pointertable,x	
	EIF
	lda #128
	sta trackn_volumeslidevalue,x
	sta trackn_instrx2,x
	asl @
	sta trackn_instrreachend,x
	sta trackn_shiftfrq,x
	tay
	lda (nt),y
	sta trackn_tableend,x
	adc #0
	sta trackn_instridx,x
	lda #INSTRPAR
	sta trackn_tablea,x
	tay
	lda (nt),y
	sta trackn_tablenote,x

	IFT FEAT_SFX||FEAT_IS_TRACKER
	rts 			
;* a rts is mandatory for the 'tracker.obx' binary, else a lot of things break in RMT! 
;* look inside 'rmtextra.a65' for the exclusive tracker.obx code
	ELS
	jmp p2x0		; go process the next channel's instrument
	EIF
	
rmt_play
rmt_p0
	jsr SetPokey
	
rmt_p1
	IFT FEAT_INSTRSPEED==0||FEAT_INSTRSPEED>1
	dec v_ainstrspeed
	bne rmt_p3
	EIF
	IFT FEAT_INSTRSPEED==0
	lda #$ff
v_instrspeed	equ *-1
	sta v_ainstrspeed
	ELI FEAT_INSTRSPEED>1
	lda #FEAT_INSTRSPEED
	sta v_ainstrspeed
	EIF
	
rmt_p2
	dec v_aspeed
	bne rmt_p3
	inc v_abeat
	lda #$ff
v_abeat equ *-1
	cmp #$ff
v_maxtracklen equ *-1
	beq p2o3
	jmp GetTrackLine
p2o3
	jmp GetSongLineTrackLineInitOfNewSetInstrumentsOnlyRmtp3
	
;go_ppnext				;* OPTIMISATION: this is no longer needed, use a JMP directly elsewhere
;	jmp ppnext

rmt_p3	

	ldx #TRACKS-1
	
;* combining the aggressive init and rmt_p3 in 1 thing, this is now an even more aggressive approach! 
	
dodex	
	lda trackn_instrhb,x
	beq dexnext			; process the next channel's bytes immediately if empty
	sta ns+1
	lda trackn_instrdb,x
	sta ns
	ldy trackn_instridx,x
	lda (ns),y			; volume byte	
	sta trackn_volumeenvelope,x	; sta reg1
	iny
	lda (ns),y			; command and distortion byte
	sta trackn_command,x		; sta reg2
	iny
	lda (ns),y			; $XY parameter byte
	sta trackn_effectparameter,x	; sta reg3
	iny
	tya
	cmp trackn_instrlen,x
	bcc dodex_a
	beq dodex_a
	lda #$80
	sta trackn_instrreachend,x
	lda trackn_instrlop,x
dodex_a
	sta trackn_instridx,x

	IFT FEAT_AUDCTLMANUALSET&&FEAT_COMMAND7
dex_cmd7	
	lda trackn_command,x
	and #$70			; clear distortion and other bits
	cmp #$70 			; command 7? 
	bne dexnext			; skip if not equal
	lda trackn_effectparameter,x	
dex_xy
	cmp #$FD                	; failsafe -> Volume Only Mode or SKCTL toggle 
	bcs dexnext	        	; skip if above or equal #$FD 
	sta trackn_audctl,x     	; overwrite the previous value	
	EIF	
	
dexnext
	dex
	bpl dodex			; continue until x is negative
dexdone
	ldx #TRACKS-1			; must get the tracks value again before the next part
	
pp0					; get AUDCTL as early as possible, properly this time!
	IFT FEAT_AUDCTLMANUALSET
	lda trackn_audctl+0
	ora trackn_audctl+1
	ora trackn_audctl+2
	ora trackn_audctl+3
	sta v_audctl	
	IFT TRACKS>4	
	lda trackn_audctl+4
	ora trackn_audctl+5
	ora trackn_audctl+6
	ora trackn_audctl+7
	sta v_audctl2		
	EIF
	ELS
	lda #0
	sta v_audctl
	IFT TRACKS>4
	sta v_audctl2
	EIF
	EIF
	
pp0_a
	IFT FEAT_AGGRESSIVE_INIT 
	jmp start_aggressive_init	; a LOT to be desired there... will be reworked in a much better way later
	EIF 	

pp1
	lda trackn_instrhb,x
	bne pp1_a			; continue if not equal, the channel will be skipped otherwise
;	beq go_ppnext			;* OPTIMISATION: skip a BEQ to proceed a JMP again, BNE and JMP directly if equal instead
	jmp ppnext
	
pp1_a					; copying the values to the zeropage to make things faster... but not all bytes need this...
	lda trackn_command,x
	sta reg2
	lda trackn_effectparameter,x
	sta reg3
	
pp2
;	lda reg1			;* OPTIMISATION: this is no longer necessary, use the value directly instead
	lda trackn_volumeenvelope,x
	IFT TRACKS>4
	cpx #4
	bcc pp2s
	lsr @
	lsr @
	lsr @
	lsr @
	EIF
pp2s
	and #$0f
	ora trackn_volume,x
	tay
	lda volumetab,y
	sta tmp

;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of manual tables code (unfinished)...

	IFT FEAT_TABLE_MANUAL		; Manual tuning table loaded from instruments, this is currently not fully implemented into RMT...
	lda trackn_pointertable,x
	beq pp2sno			; a value of 0 means no pointer will be used, thus, can be skipped immediately
	tay
	and #$0F
	ora #$B0
	sta nr+1			; Bx00, where x is manipulated
	tya
	and #$C0
	sta nr				; B0x0, where is manipulated
	lda reg2
	and #$0e
	tay
	jmp pp2syes
	EIF
	
;* end of manual tables code...
	
;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* start of the tuning tables code... Should be much faster and efficient this time...

do_tuning_tables
	lda reg2		; Distortion and Command
	and #$0E		; Only keep the Distortion bits
	tay			; will be used for the tables MSB pointer, and the Distortion itself	
	cpy #$06		; are we using Distortion 6?
	bne check_flags		; if not equal, continue like normal
	lda tmp			; volume backup
	beq check_flags		; if the volume is 0, continue like normal	
	jmp do_bass16		;* process the BASS16 code from here if the initial test passed
check_flags
	lda trackn_flags,x	; flags previously set during the aggressive rmt_p3 initialisation, they are unconditional
	beq store_tables_lsb	; #$00 = 64khz mode, unconditional
	bmi check_valid_16bit	; #$80 = Valid 16-bit channel, #$FF = Invalid 16-bit channel
	cmp #$40		; is the 1.79mhz flag set? if the value is above #$40, the sawtooth flag of #$7F is also set
	beq store_tables_lsb	; if equal, the tables LSB pointer is the flag value, no further action needed	
	bcc check_15khz		; a value below #$40 means the only possible outcome is a value of #$01, for 15khz mode
check_sawtooth
	cpy #$0A		; are we also using Distortion A?
	beq check_sawtooth_b	; if equal, Distortion A is used, else, the sawtooth code is immediately skipped as a failsafe
check_sawtooth_a
	lda #$40		; 1.79mhz mode flag, which is also the tables LSB pointer
	bne store_tables_lsb	; unconditional
check_sawtooth_b
	lda tmp			; volume value backup
	beq check_sawtooth_a	; volume 0 is immediate skip of sawtooth code
	jmp do_sawtooth		;* process the sawtooth code from here if all tests passed
check_15khz
	cpy #$0C		; are we in Distortion C/E?
	bcs check_15khz_b	; if equal or above, use the Distortion C 15khz table, else, use the Distortion A 15khz table
	lda #<frqtabpure_15khz	; Distortion A 15khz table LSB
	bne check_15khz_c	; unconditional
check_15khz_b
	lda #<frqtabbuzzy_15khz	; Distortion C 15khz table LSB
check_15khz_c
	sta nr
	lda #>PAGE_EXTRA_0	; tables MSB pointer, it's the same one regardless of the table used
	bne store_tables_lsb_a	; unconditional 
check_valid_16bit
	cmp #$FF		; is the Invalid flag set?
	beq hellno		; branch to failsafe if yes, we do not want sound in the Invalid channels!
check_valid_16bit_a	
	cpy #$06		; are we using Distortion 6?
	bne check_valid_16bit_b	; if not equal, continue like normal
	jmp process_bass16	; else, execute the BASS16 code immediately since the 16-bit flag is set
check_valid_16bit_b
	sta nr			; 16-bit hi LSB
	lda #$C0		; 64 bytes further for the 16-bit LSB table
	sta pointer16bitlo  	; 16-bit lo LSB
	lda #0			; no volume output, Distortion also won't matter
	sta trackn_audc-1,x	; process the next channel's AUDC early, since 16-bit mode being active	will skip it
	lda TABLES_MSB,y
	sta pointer16bitlo+1	; 16-bit lo MSB
	bne store_tables_lsb_a	; unconditional, finish in the middle of the 64khz/1.79mhz branch
hellno
	lda #0			; no volume and frequency of 0, to set the channel to a unused state
	sta trackn_audc,x
	sta trackn_audf,x
	jmp ppnext 		; skip this channel entirely if the failsafe branch occured
store_tables_lsb
	sta nr			; tables LSB pointer, divided in slices of 64 bytes each
	lda TABLES_MSB,y
store_tables_lsb_a
	sta nr+1		; tables MSB pointer, which is the memory page used for tables divided based on their Distortion
store_tables_lsb_b
	lda tmp			; volume value backup
	ora DISTORTIONS,y	; merge the Distortion and Volume values
store_tables_lsb_c
	sta trackn_audc,x	; update the channel's AUDC for the next SetPokey subroutine call
	
;* end of tuning tables code...

;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* start of instruments effect code...
	
InstrumentsEffects
	IFT FEAT_EFFECTS
	lda trackn_effdelay,x
	beq ei2
	
; possible improvement: use CMP #2 instead? This could save a CLC instruction...
;	cmp #2			; if A >= 2 -> skip, 
;	bcs ei1			; if A < 2 -> carry flag not set, so it must be A = 1, 0 was done with beq ei2
	
	cmp #1
	bne ei1
	lda trackn_shiftfrq,x
	IFT FEAT_EFFECTFSHIFT
	clc
	adc trackn_effshift,x
	EIF
	IFT FEAT_EFFECTVIBRATO
	clc
	ldy trackn_effvibratoa,x
	adc vib0,y
	EIF
	sta trackn_shiftfrq,x
	IFT FEAT_EFFECTVIBRATO
	lda vibtabnext,y
	sta trackn_effvibratoa,x
	EIF
	jmp ei2
ei1
	dec trackn_effdelay,x
ei2
	EIF
	ldy trackn_tableend,x
	cpy #INSTRPAR+1
	bcc ei3
	lda trackn_tablespeeda,x
	bpl ei2f
ei2c
	tya
	cmp trackn_tablea,x
	bne ei2c2
	IFT FEAT_TABLEGO
	lda trackn_tablelop,x
	ELS
	lda #INSTRPAR
	EIF
	sta trackn_tablea,x
	bne ei2a
ei2c2
	inc trackn_tablea,x
ei2a
	lda trackn_instrdb,x
	sta nt
	lda trackn_instrhb,x
	sta nt+1
	ldy trackn_tablea,x
	lda (nt),y
	IFT FEAT_TABLEMODE
	ldy trackn_tablemode,x
	beq ei2e
	clc
	adc trackn_tablenote,x
ei2e
	EIF
	sta trackn_tablenote,x
	lda trackn_tabletypespeed,x
	IFT FEAT_TABLETYPE||FEAT_TABLEMODE
	and #$3f
	EIF
ei2f
	sec
	sbc #1
	sta trackn_tablespeeda,x
ei3
	lda trackn_instrreachend,x
	bpl ei4
	lda trackn_volume,x
	beq ei4
	IFT FEAT_VOLUMEMIN
	cmp trackn_volumemin,x
	beq ei4
	bcc ei4
	EIF
	tay
	lda trackn_volumeslidevalue,x
	clc
	adc trackn_volumeslidedepth,x
	sta trackn_volumeslidevalue,x
	bcc ei4
	tya
	sbc #16
	sta trackn_volume,x
ei4
	IFT FEAT_COMMAND2
	lda #0
	sta frqaddcmd2
	EIF
	IFT FEAT_COMMAND1||FEAT_COMMAND2||FEAT_COMMAND3||FEAT_COMMAND4||FEAT_COMMAND5||FEAT_COMMAND6||FEAT_COMMAND7	
	lda reg2
	
;	IFT FEAT_FILTER
;	sta trackn_command,x	;* OPTIMISATION: this is no longer necessary
;	EIF

	and #$70
	IFT 1==[FEAT_COMMAND1+FEAT_COMMAND2+FEAT_COMMAND3+FEAT_COMMAND4+FEAT_COMMAND5+FEAT_COMMAND6+FEAT_COMMAND7]	
	beq cmd0
	ELS
	lsr @
	lsr @
	sta jmx+1
jmx	bcc *
	jmp cmd0
	nop
	jmp cmd1
	IFT FEAT_COMMAND2||FEAT_COMMAND3||FEAT_COMMAND4||FEAT_COMMAND5||FEAT_COMMAND6||FEAT_COMMAND7	
	nop
	jmp cmd2
	EIF
	IFT FEAT_COMMAND3||FEAT_COMMAND4||FEAT_COMMAND5||FEAT_COMMAND6||FEAT_COMMAND7	
	nop
	jmp cmd3
	EIF
	IFT FEAT_COMMAND4||FEAT_COMMAND5||FEAT_COMMAND6||FEAT_COMMAND7	
	nop
	jmp cmd4
	EIF
	IFT FEAT_COMMAND5||FEAT_COMMAND6||FEAT_COMMAND7	
	nop
	jmp cmd5
	EIF
	IFT FEAT_COMMAND6||FEAT_COMMAND7 
	nop
	jmp cmd6
	EIF
	IFT FEAT_COMMAND7 
	nop
	jmp cmd7
	EIF
	EIF
;	ELS
;	IFT FEAT_FILTER
;	lda reg2
;	sta trackn_command,x 	;* OPTIMISATION: this is no longer necessary
;	EIF
	EIF
	
;* end of instruments effects code...
	
;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of instruments commands code... this is a direct followup of the instruments effects code.
	
cmd1
	IFT FEAT_COMMAND1
	IFT FEAT_FULL_TABLES_HIJACK||FEAT_BASS16
	IFT FEAT_FULL_16BIT||FEAT_BASS16
	lda pointer16bitlo+1
	beq cmd1a		; 16-bit mode not active
	lda #0			; force the LSB channel to have empty values as a failsafe
	sta trackn_audc-1,x
	sta trackn_audf-1,x
	EIF
	EIF
cmd1a	
	lda reg3
	jmp cmd0c
	EIF
cmd2
	IFT FEAT_COMMAND2
	lda reg3
	sta frqaddcmd2
	lda trackn_note,x
	jmp cmd0a
	EIF
cmd3
	IFT FEAT_COMMAND3
	lda trackn_note,x
	clc
	adc reg3
	sta trackn_note,x
	jmp cmd0a
	EIF
cmd4
	IFT FEAT_COMMAND4
	lda trackn_shiftfrq,x
	clc
	adc reg3
	sta trackn_shiftfrq,x
	lda trackn_note,x
	jmp cmd0a
	EIF
cmd5
	IFT FEAT_COMMAND5&&FEAT_PORTAMENTO
	IFT FEAT_TABLETYPE
	lda trackn_tabletypespeed,x
	bpl cmd5a1
	ldy trackn_note,x
	lda (nr),y
	clc
	adc trackn_tablenote,x
	jmp cmd5ax
	EIF
cmd5a1
	lda trackn_note,x
	clc
	adc trackn_tablenote,x
	cmp #61
	bcc cmd5a2
	lda #63
cmd5a2
	tay
	lda (nr),y
cmd5ax
	sta trackn_portafrqc,x
	ldy reg3
	bne cmd5a
	sta trackn_portafrqa,x
cmd5a
	tya
	lsr @
	lsr @
	lsr @
	lsr @
	sta trackn_portaspeed,x
	sta trackn_portaspeeda,x
	lda reg3
	and #$0f
	sta trackn_portadepth,x
	lda trackn_note,x
	jmp cmd0a
	ELI FEAT_COMMAND5
	lda trackn_note,x
	jmp cmd0a
	EIF
cmd6
	IFT FEAT_COMMAND6&&FEAT_FILTER
	
	IFT FEAT_FULL_TABLES_HIJACK||FEAT_FULL_16BIT||FEAT_BASS16
	IFT FEAT_FULL_SAWTOOTH&&FEAT_FULL_TABLES_HIJACK
	lda sawtoothtables+1
	bne cmd6b		; sawtooth active, failsafe
	EIF
	IFT FEAT_FULL_16BIT||FEAT_BASS16
	lda pointer16bitlo+1
	bne cmd6b		; 16-bit mode active, failsafe
	EIF
	EIF
	
cmd6a	
	lda reg3
	clc
	adc trackn_filter,x
	sta trackn_filter,x
	
cmd6b
	lda trackn_note,x
	jmp cmd0a
	ELI FEAT_COMMAND6
	lda trackn_note,x
	jmp cmd0a
	EIF
cmd7
	IFT FEAT_COMMAND7
	
	IFT FEAT_COMMAND7SETNOTE||FEAT_COMMAND7VOLUMEONLY
	IFT FEAT_TWO_TONE
	lda reg3
	bpl cmd7f		; failsafe, quick and immediate, there will be no Two-Tone toggle, or volume only output, since the command was most likely used to set the AUDCTL bits
	cmp #$FD		; #$FD toggles Two-Tone off
	bcc cmd7f		; no values will match if less than this, failsafe in case the BPL above didn't catch it
	beq cmd7b		; turn off the Two-Tone Filter if equal
	cmp #$FE		; #$FE toggles Two-Tone on
	beq cmd7c		; turn on the Two-Tone Filter if equal
	IFT FEAT_COMMAND7VOLUMEONLY	
	bne cmd7a		; #$FF sets volume only mode, and will always be that value here, unconditional branching
	ELS
	bne cmd7f		; skip ahead, and don't set volume only mode either
	EIF
cmd7b				
	lda #3			; disable the Two-Tone Filter with this value
	bne cmd7d		; unconditional
cmd7c				
	lda #$8B		; enable the Two-Tone Filter with this value
cmd7d
	IFT TRACKS>4
	cpx #4
	bcc cmd7e		; less than 4
	sta v_skctl2		; SKCTL, Right POKEY 
	bcs cmd7f		; carry flag still set, unconditional
	EIF
cmd7e
	sta v_skctl		; SKCTL, Left POKEY
	ELS
	
	IFT FEAT_COMMAND7VOLUMEONLY	
	lda reg3
	bpl cmd7f		; failsafe, quick and immediate, there will be no Two-Tone toggle, or volume only output, since the command was most likely used to set the AUDCTL bits
	cmp #$FF
	beq cmd7a		; set volume only mode if equal
	EIF
	EIF
cmd7f
	lda trackn_note,x	; this is the expected variable in memory
	jmp cmd0a 
cmd7a

	IFT FEAT_COMMAND7VOLUMEONLY
	lda trackn_audc,x
	ora #$f0
	sta trackn_audc,x
	lda trackn_note,x
	jmp cmd0a
	EIF
	
	ELS
	lda trackn_note,x	; this is the expected variable in memory
	jmp cmd0a 
	EIF
	
	EIF
cmd0
	lda trackn_note,x
	clc
	adc reg3
cmd0a
	IFT FEAT_TABLETYPE
	ldy trackn_tabletypespeed,x
	bmi cmd0b
	EIF
	clc
	adc trackn_tablenote,x
	cmp #61
	bcc cmd0a1
	lda #0
	sta trackn_audc,x
	lda #63
cmd0a1
	tay
	
	IFT FEAT_FULL_TABLES_HIJACK||FEAT_BASS16
	IFT FEAT_FULL_16BIT||FEAT_BASS16
	lda pointer16bitlo+1
	beq cmd0a2		; 16-bit mode not active
	lda (nr),y
	sta trackn_audf,x	; get and store the MSB early
	lda trackn_shiftfrq,x
	IFT FEAT_COMMAND2
	clc
	adc frqaddcmd2
	EIF
	sta tmp			; get and store the frequency shift early, combined if CMD2 is also enabled
	bmi cmd0a1sub		; will subtract 1 from the MSB if negative on overflow
cmd0a1add
	lda (pointer16bitlo),y
	clc
	adc tmp
	sta trackn_audf-1,x	; LSB 16-bit channel, update early here
	bcc cmd0a1adddone	; no overflow, done
	inc trackn_audf,x	; increment the MSB if the value went past #$FF
cmd0a1adddone	
	jmp pp9			; done
cmd0a1sub
	lda (pointer16bitlo),y
	clc
	adc tmp
	sta trackn_audf-1,x	; LSB 16-bit channel, update early here
	bcs cmd0a1adddone	; no overflow, done
	dec trackn_audf,x	; decrement the MSB if the value went past #$00
cmd0a1subdone	
	jmp pp9			; done
	EIF
	
cmd0a2	
	IFT FEAT_FULL_SAWTOOTH&&FEAT_FULL_TABLES_HIJACK
	lda sawtoothtables+1
	beq cmd0a3		; sawtooth not active
	lda (sawtoothtables),y
	clc
	adc trackn_shiftfrq,x
	IFT FEAT_COMMAND2
	clc
	adc frqaddcmd2
	EIF	
	sta trackn_audf+2,x	; since we're in channel 1 of either POKEY, offset +2 will always be the 3rd channel
	EIF
	EIF

cmd0a3
	lda (nr),y
	clc
	adc trackn_shiftfrq,x
	IFT FEAT_COMMAND2
	clc
	adc frqaddcmd2
	EIF
	
	IFT FEAT_TABLETYPE
	jmp cmd0c
cmd0b
	cmp #61
	bcc cmd0b1
	lda #0
	sta trackn_audc,x
	lda #63
cmd0b1
	tay
	
	IFT FEAT_FULL_TABLES_HIJACK||FEAT_BASS16
	IFT FEAT_FULL_16BIT||FEAT_BASS16
	lda pointer16bitlo+1
	beq cmd0b2		; 16-bit mode not active
	lda (nr),y
	sta trackn_audf,x	; get and store the MSB early
	lda trackn_shiftfrq,x
	clc
	adc trackn_tablenote,x
	clc	
	IFT FEAT_COMMAND2
	clc
	adc frqaddcmd2
	EIF
	sta tmp			; get and store the frequency shift early, combined if CMD2 is also enabled
	bmi cmd0b1sub		; will subtract 1 from the MSB if negative on overflow
cmd0b1add
	lda (pointer16bitlo),y
	clc
	adc tmp
	sta trackn_audf-1,x	; LSB 16-bit channel, update early here
	bcc cmd0b1adddone	; no overflow, done
	inc trackn_audf,x	; increment the MSB if the value went past #$FF
cmd0b1adddone	
	jmp pp9			; done
cmd0b1sub
	lda (pointer16bitlo),y
	clc
	adc tmp
	sta trackn_audf-1,x	; LSB 16-bit channel, update early here
	bcs cmd0b1adddone	; no overflow, done
	dec trackn_audf,x	; decrement the MSB if the value went past #$00
cmd0b1subdone	
	jmp pp9			; done
	EIF
	
cmd0b2	
	IFT FEAT_FULL_SAWTOOTH&&FEAT_FULL_TABLES_HIJACK
	lda sawtoothtables+1
	beq cmd0b3		; sawtooth not active
	lda trackn_shiftfrq,x
	clc
	adc trackn_tablenote,x
	clc
	adc (sawtoothtables),y
	IFT FEAT_COMMAND2
	clc
	adc frqaddcmd2
	EIF	
	sta trackn_audf+2,x	; since we're in channel 1 of either POKEY, offset +2 will always be the 3rd channel
	EIF
	EIF

cmd0b3
	lda trackn_shiftfrq,x
	clc
	adc trackn_tablenote,x
	clc
	adc (nr),y
	IFT FEAT_COMMAND2
	clc
	adc frqaddcmd2
	EIF
	EIF
cmd0c
	sta trackn_audf,x
	
;* end of instruments commands code... 
	
;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* start of Portamento code... This is currently not properly compatible with 16-bit mode, unfortunately.
	
pp9
	IFT FEAT_PORTAMENTO
	lda trackn_portaspeeda,x
	beq pp10
	dec trackn_portaspeeda,x
	bne pp10
	lda trackn_portaspeed,x
	sta trackn_portaspeeda,x
	lda trackn_portafrqa,x
	cmp trackn_portafrqc,x
	beq pp10
	bcs pps1
	adc trackn_portadepth,x
	bcs pps8
	cmp trackn_portafrqc,x
	bcs pps8
	jmp pps9
pps1
	sbc trackn_portadepth,x
	bcc pps8
	cmp trackn_portafrqc,x
	bcs pps9
pps8
	lda trackn_portafrqc,x
pps9
	sta trackn_portafrqa,x
pp10
	lda reg2
	and #$01
	beq pp11
	lda trackn_portafrqa,x
	clc
	adc trackn_shiftfrq,x	
pp10a	
	sta trackn_audf,x
pp11
	EIF

;* end of Portamento code...

;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* part of mainloop code... this is an extra step added for the purpose of clearning the memory from 16-bit or Sawtooth addresses when unused.

	IFT FEAT_FULL_TABLES_HIJACK||FEAT_BASS16
	ldy #0			; reset the values to 0, until the next player call since they're no longer needed for checks
	
	IFT FEAT_FULL_SAWTOOTH&&FEAT_FULL_TABLES_HIJACK
;	lda sawtoothtables+1
;	beq pp11a		; sawtooth not active
;	lda #0			; reset the values to 0, until the next player call since they're no longer needed for checks
				;* OPTIMISATION: trying to help it a bit... this needs a much better fix...
	sty sawtoothtables
	sty sawtoothtables+1
	EIF
pp11a
	IFT FEAT_FULL_16BIT||FEAT_BASS16
	lda pointer16bitlo+1
	beq ppnext		; 16-bit mode not active
;	lda #0			; reset the values to 0, until the next player call since they're no longer needed for checks

	sty pointer16bitlo
	sty pointer16bitlo+1
	dex			;* skip the next channel since it was updated early!!
	EIF
	EIF
	
ppnext
	dex
	bmi rmt_p4
	jmp pp1
rmt_p4

;* end of mainloop code... everything below will be conditionally assembled for easy optimisation.
	
;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of Autofilter code... a much more stripped down version

	IFT FEAT_FILTER
	ldx v_audctl 
qq1
	IFT FEAT_FILTERG0L
	lda trackn_command+0
	bpl qq2
	lda trackn_audc+0
	and #$0f
	beq qq2
	lda trackn_audf+0
	clc
	adc trackn_filter+0
	sta trackn_audf+2
qq1a
	txa
	ora #4
	tax
	EIF
qq2
	IFT FEAT_FILTERG1L
	lda trackn_command+1
	bpl qq3
	lda trackn_audc+1
	and #$0f
	beq qq3
	lda trackn_audf+1
	clc
	adc trackn_filter+1
	sta trackn_audf+3
qq2a
	txa
	ora #2
	tax
	EIF
qq3
	stx v_audctl
	EIF
	
	IFT FEAT_FILTER&&TRACKS>4
	ldx v_audctl2 
	IFT FEAT_FILTERG0R
	lda trackn_command+0+4
	bpl qs2
	lda trackn_audc+0+4
	and #$0f
	beq qs2
	lda trackn_audf+0+4
	clc
	adc trackn_filter+0+4
	sta trackn_audf+2+4
qs1a
	txa
	ora #4
	tax
	EIF
qs2
	IFT FEAT_FILTERG1R
	lda trackn_command+1+4
	bpl qs3
	lda trackn_audc+1+4
	and #$0f
	beq qs3
	lda trackn_audf+1+4
	clc
	adc trackn_filter+1+4
	sta trackn_audf+3+4
qs2a
	txa
	ora #2
	tax
	EIF
qs3
	stx v_audctl2
	EIF
	
;* end of Autofilter code...

;---------------------------------------------------------------------------------------------------------------------------------------------;	
	
;* return of instrument speed code here... I wonder if there may be a way to exploit this?
	
rmt_p5		;* OPTIMISATION: seems like this was not necessary, end directly with a RTS
	rts 
	
;	IFT FEAT_INSTRSPEED==0||FEAT_INSTRSPEED>1
;	lda #$ff
;v_ainstrspeed equ *-1
;	ELS
;	lda #1
;	EIF
;	rts

;---------------------------------------------------------------------------------------------------------------------------------------------;

;* start of Sawtooth code...

do_sawtooth
	IFT FEAT_FULL_SAWTOOTH
	lda reg2
	bpl hijack_sawtooth_done	; AUTOFILTER command is off, skip overwriting the other things	
	IFT FEAT_FILTER
	eor #$80			; inverts the AUTOFILTER bit, so it does not overwrite things later
;	sta reg2			; store back to reg2 for later
	sta trackn_command,x		;* OPTIMISATION: overwrite the command byte until the AUTOFILTER code since things where done early
	EIF
	lda #4				; high pass filter, CH1+3
	IFT TRACKS>4			; stereo mode
	cpx #4				; are we in the right POKEY channels?
	bcc sawtooth_audctl_mono	; if x is lower than 4, we are not
	ora v_audctl2			; combine the existing AUDCTL value to it
	sta v_audctl2			; store the new AUDCTL value, right POKEY
	bne sawtooth_audctl_done	; unconditional
	EIF
sawtooth_audctl_mono	
	ora v_audctl			; combine the existing AUDCTL value to it
	sta v_audctl			; store the new AUDCTL value, left POKEY
sawtooth_audctl_done
	IFT FEAT_COMMAND6		; Sawtooth CMD6 hack... could be optimised much better, or maybe moved into the commands? 
	lda reg2			; Command and Distortion
	and #$70			; keep the Command bits only
	cmp #$60			; CMD6?
	bne hijack_sawtooth_done	; skip if not equal
	lda reg3			; $XY parameter
	beq hijack_sawtooth_done	; skip if the value is 0, nothing will be changed
	bmi sawtooth_reverse		; negative values (#$80 to #$FF) will reverse the pointers, positive values (#$01 to #$7F) will set the pointers back to normal
sawtooth_normal
	lda #<frqtabsawtooth_ch1
	sta saw_ch1
	lda #<frqtabsawtooth_ch3
	sta saw_ch3	
	bpl hijack_sawtooth_done
sawtooth_reverse
	lda #<frqtabsawtooth_ch3
	sta saw_ch1
	lda #<frqtabsawtooth_ch1
	sta saw_ch3	
	EIF
hijack_sawtooth_done
	lda #<frqtabsawtooth_ch1
saw_ch1	equ *-1	
	sta nr 
	lda #<frqtabsawtooth_ch3
saw_ch3	equ *-1	
	sta sawtoothtables
hijack_sawtooth_done_a
	lda #>PAGE_EXTRA_0		; tables MSB pointer, it's the same one regardless of the table used
	sta sawtoothtables+1		; for the other channel later, also used as a check if it is enabled	
	jmp store_tables_lsb_a		; finish in the middle of the 64khz/1.79mhz branch
	EIF

;* end of Sawtooth code...

;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* start of BASS16 code...

do_bass16	
	IFT FEAT_BASS16		
	IFT TRACKS>4			; stereo mode
	cpx #4				; are we in the right POKEY channels?
	bcc test_bass16_ch4_mono	; if x is lower than 4, we are not
test_bass16_ch4_stereo
	cpx #7				; channel 4?
	bne test_bass16_ch2_stereo
	lda #$28			; JOIN_34 + CH3_179 bits 
	bne bass16_audctl_done_stereo	; unconditional
test_bass16_ch2_stereo	
	cpx #5				; channel 2?
	bne no_bass16			; no valid channel detected
	lda #$50			; JOIN_12 + CH1_179 bits 
bass16_audctl_done_stereo
	ora v_audctl2	
	sta v_audctl2
	bne process_bass16		; process the remaining BASS16 code from here
	EIF
test_bass16_ch4_mono	
	cpx #3				; channel 4?
	bne test_bass16_ch2_mono
	lda #$28			; JOIN_34 + CH3_179 bits 
	bne bass16_audctl_done_mono	; unconditional
test_bass16_ch2_mono
	cpx #1				; channel 2?
	bne no_bass16			; no valid channel detected
	lda #$50			; JOIN_12 + CH1_179 bits 
bass16_audctl_done_mono	
	ora v_audctl
	sta v_audctl	
process_bass16	
	IFT FEAT_COMMAND6&&FEAT_FULL_16BIT
	lda reg2			; Distortion and Commands
	and #$70			; leave only the Commands bits
	cmp #$60			; CMD6?
	bne process_bass16_a		; skip if not CMD6
	lda reg3			; XY parameter
	beq process_bass16_a		; immediately skip if the value is 0, nothing will be changed
	and #$0E			; strip away all unwanted bits, left nybble will not affect anything
	sta bass16_pointer		; PERMANENTLY change the value until a new CMD6 value is read
	EIF
	IFT FEAT_FULL_16BIT	
process_bass16_a
	ldy #$0A			; Distortion A
bass16_pointer equ *-1
	lda #$80
	jmp check_valid_16bit_b		; process the remaining of the 16-bit code from there
no_bass16
	jmp check_flags			; abort the BASS16 code immediately if the execution landed here
	ELS	
	lda #<frqtabpure_hi
	sta nr
	lda #<frqtabpure_lo
	sta pointer16bitlo 	
	lda #0				
	sta trackn_audc-1,x		; update the next channel's AUDC early, it will always be volume 0, and Distortion won't matter
	lda #>PAGE_DISTORTION_A
	sta pointer16bitlo+1		; this value can also be used to identify if 16-bit mode is active or not, since it will never be 0
	sta nr+1
	lda tmp
	ora #$A0
	jmp store_tables_lsb_c
	EIF
	EIF

;* end of BASS16 code...

;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* start of the aggresive init code... 

;* this is an experimental feature, it may or may not work at all!

;* some bytes, arbitrarily distributed as flags:
;*
;* #$00 == Nothing! This is a free BEQ, useful for skipping code when it is encountered. This flag may save a ton of cycles in most situations.
;* #$FF == Something is wrong! Abort everything if encountered, and skip to the next channel! eg: invalid 16-bit output, possibly more if necessary...
;* #$01 == 15khz mode, for any channel. This one should always be correct when the bit is set, so it is important to not miss it.
;* #$80 == 16-bit mode, for valid channels ONLY! When 16-bit mode is used, the next channel will be skipped, saving cycles in the process.
;* #$40 == 1.79mhz mode, for valid channels ONLY! Normal 64khz or 15khz mode will be used otherwise.
;* #$7F == Sawtooth mode, for valid channels ONLY! A few additional tests in the tables routine will be necessary. Fallback to 1.79mhz mode otherwise.


;* POTENTIAL IMPROVEMENT: use reverse logic, AUDCTL first, channel number after?
FUCK_NO	equ 0


	IFT FEAT_AGGRESSIVE_INIT&&FUCK_NO
start_aggressive_init

	IFT TRACKS>4			; stereo mode
	lda v_audctl2			; left POKEY, if it was not initialised early, there may be 1 frame of delay, at worst
	beq start_aggressive_init_d	; if AUDCTL = 0, zeroes will be written in the flag bytes, clearing any old data
	cmp #$FF			; always execute for the first time with this value
old_v_audctl2 equ *-1			; are the values identical?
	beq start_aggressive_init_c	; if equal, flags won't be updated for this time, cycles won't be wasted
	tay 				; backup the AUDCTL value into index Y
	bne do_aggressive_init		; unconditional
start_aggressive_init_d
	sta trackn_flags+4		; clear the instrument flags for this POKEY here, will always be 0 unconditionally
	sta trackn_flags+5
	sta trackn_flags+6
	sta trackn_flags+7
start_aggressive_init_c
	ldx #3				; since there are only 4 channels per POKEY, load the proper channel index value here
	EIF				; endif
	
start_aggressive_init_b
	lda v_audctl			; left POKEY, if it was not initialised early, there may be 1 frame of delay, at worst
	beq start_aggressive_init_e	; if AUDCTL = 0, zeroes will be written in the flag bytes, clearing any old data
	cmp #$FF			; are the values identical?
old_v_audctl equ *-1			; OPTIMISATION: self modifiying code
	beq done_aggressive_init	; if equal, flags won't be updated for this time, cycles won't be wasted
	tay				; backup the AUDCTL value into index Y
	bne do_aggressive_init		; unconditional
start_aggressive_init_e	
	sta trackn_flags+0		; clear the instrument flags for this POKEY here, will always be 0 unconditionally
	sta trackn_flags+1
	sta trackn_flags+2
	sta trackn_flags+3	
	beq done_aggressive_init	; unconditional, flags won't be updated further, cycles won't be wasted
do_aggressive_init 
	; something

done_aggressive_init
	ldx #TRACKS-1
	jmp pp1
	EIF
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	IFT !FUCK_NO
start_aggressive_init
	IFT TRACKS>4			; stereo mode
	lda v_audctl2			; left POKEY, if it was not initialised early, there may be 1 frame of delay, at worst
	beq start_aggressive_init_d	; if AUDCTL = 0, zeroes will be written in the flag bytes, clearing any old data
	cmp #$FF			; always execute for the first time with this value
old_v_audctl2 equ *-1			; OPTIMISATION: self modifiying code
	
	beq start_aggressive_init_c	; if equal, flags won't be updated for this time, cycles won't be wasted
	tay 				; backup the AUDCTL value into index Y
	bne do_ch4			; unconditional, start on the first known position, saving a redundant check
start_aggressive_init_d
	sta trackn_flags+4		; clear the instrument flags for this POKEY here, will always be 0 unconditionally
	sta trackn_flags+5
	sta trackn_flags+6
	sta trackn_flags+7
start_aggressive_init_c
	ldx #3				; since there are only 4 channels per POKEY, load the proper channel index value here
	EIF				; endif
start_aggressive_init_b
	lda v_audctl			; left POKEY, if it was not initialised early, there may be 1 frame of delay, at worst
	beq start_aggressive_init_e	; if AUDCTL = 0, zeroes will be written in the flag bytes, clearing any old data
	cmp #$FF			; always execute for the first time with this value
old_v_audctl equ *-1			; OPTIMISATION: self modifiying code

	beq done_aggressive_init	; if equal, flags won't be updated for this time, cycles won't be wasted
	tay				; backup the AUDCTL value into index Y
	bne do_ch4_a			; unconditional, start on the first known position, saving a redundant check
start_aggressive_init_e	
	sta trackn_flags+0		; clear the instrument flags for this POKEY here, will always be 0 unconditionally
	sta trackn_flags+1
	sta trackn_flags+2
	sta trackn_flags+3	
	beq done_aggressive_init	; unconditional, flags won't be updated further, cycles won't be wasted
do_aggressive_init 
	IFT TRACKS>4			; stereo mode
	cpx #4				; are we in the right POKEY channels?
	bcc do_ch4_a			; if x is lower than 4, we are not
	beq do_179_ch1			; if equal, process the 1.79mhz ch1 checks
do_ch4
	cpx #7				; channel 4?
	beq do_join_34			; if equal, process the Join 3+4 checks
do_ch3	
	cpx #6				; channel 3?
	beq do_179_ch3			; if equal, process the 1.79mhz ch3 checks
do_ch2	
	cpx #5				; channel 2?
	beq do_join_12			; if equal, process the Join 1+2 checks
	EIF				; endif, all of the Right POKEY's channel are done
do_ch4_a
	cpx #3				; channel 4?
	beq do_join_34			; if equal, process the Join 3+4 checks
do_ch3_a	
	cpx #2				; channel 3?
	beq do_179_ch3			; if equal, process the 1.79mhz ch3 checks
do_ch2_a	
	cpx #1				; channel 2?
	beq do_join_12			; if equal, process the Join 1+2 checks
do_179_ch1				; x being equal to 0 is unconditional here, process the 1.79mhz ch1 checks.
	bit CH1_179
	beq do_clock_15			; no 1.79mhz mode in channel 1, skip ahead, else, run the cycle of endless checks
	bit JOIN_12
	bne do_fail_here		; branch to failsafe, 16-bit volume output should not happen in this channel
	bit CH3_179			
	bne do_saw_here			; if 1.79mhz mode is also active in channel 3, load the Triangle/Sawtooth value, else, branch to 1.79mhz mode value	
do_179_here
	lda #$40 			; 1.79mhz mode
	bne loop_aggressive_init	; unconditional	
do_179_ch3
	bit CH3_179
	beq do_clock_15			; no 1.79mhz mode in channel 3, skip ahead to 15khz mode check
	bit JOIN_34
	beq do_179_here			; branch to failsafe, 16-bit volume output should not happen in this channel
do_fail_here
	lda #$FF			; Invalid 16-bit mode
	bne loop_aggressive_init	; unconditional		
do_join_34
	bit JOIN_34
	beq do_clock_15			; if no join, skip directly to 15khz checks
	bit CH3_179
	beq do_clock_15			; no 1.79mhz mode in channel 3, skip ahead to 15khz mode check
do_join_here
	lda #$80			; Valid 16-bit mode
	bne loop_aggressive_init	; unconditional	
do_join_12
	bit JOIN_12
	beq do_clock_15			; if no join, skip directly to 15khz checks
	bit CH1_179
	bne do_join_here
do_clock_15
	and #$01			; AND instruction here, if the 15khz mode is off, the result will always be 0, regardless of every other bits
loop_aggressive_init
	sta trackn_flags,x
	dex
	bmi done_aggressive_init	; index x has overflown, so the loop is finished
	IFT TRACKS>4
	cpx #3				; since there are only 4 channels per POKEY, this step is necessary in stereo mode in case it was skipped
	beq start_aggressive_init_b	; if equal, process the remaining 4 channels, but first the proper AUDCTL value must be loaded
	EIF
loop_aggressive_init_a
	tya				; fetch the AUDCTL backup before continuing into the loop
	bne do_aggressive_init		; unconditional, AUDCTL is never going to be 0 here
done_aggressive_init
	ldx #TRACKS-1
	jmp pp1
do_saw_here				;* I had to move this here to save a few bytes for a BEQ, I cry a little
	lda #$7F			; Sawtooth mode
	bne loop_aggressive_init	; unconditional	
	EIF 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
; end of aggressive init code...

;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* start of the SetPokey routines...

SetPokey
	ldy #0
v_audctl equ *-1			; left POKEY AUDCTL is loaded as the very first thing, for all STEREOMODE variations

	IFT STEREOMODE==1		;* L1 L2 L3 L4 R1 R2 R3 R4
	lda trackn_audf+0+4
	ldx trackn_audf+0
	sta $d210
	stx $d200
	lda trackn_audc+0+4
	ldx trackn_audc+0
	sta $d211
	stx $d201
	lda trackn_audf+1+4
	ldx trackn_audf+1
	sta $d212
	stx $d202
	lda trackn_audc+1+4
	ldx trackn_audc+1
	sta $d213
	stx $d203
	lda trackn_audf+2+4
	ldx trackn_audf+2
	sta $d214
	stx $d204
	lda trackn_audc+2+4
	ldx trackn_audc+2
	sta $d215
	stx $d205
	lda trackn_audf+3+4
	ldx trackn_audf+3
	sta $d216
	stx $d206
	lda trackn_audc+3+4
	ldx trackn_audc+3
	sta $d217
	stx $d207
	lda #0
v_audctl2 equ *-1
	sty $d208
	sta $d218
	
	IFT FEAT_AGGRESSIVE_INIT
	sty old_v_audctl
	sta old_v_audctl2	
	EIF
	
	IFT FEAT_TWO_TONE
	lda #$03
v_skctl equ *-1	
	ldy #$03
v_skctl2 equ *-1
	sta $d20f	
	sty $d21f		
	EIF
	
	ELI STEREOMODE==0		;* L1 L2 L3 L4
	lda trackn_audf+0
	ldx trackn_audc+0
	sta $d200
	stx $d201
	lda trackn_audf+1
	ldx trackn_audc+1
	sta $d200+2
	stx $d201+2
	lda trackn_audf+2
	ldx trackn_audc+2
	sta $d200+4
	stx $d201+4
	lda trackn_audf+3
	ldx trackn_audc+3
	sta $d200+6
	stx $d201+6
	sty $d208
	
	IFT FEAT_TWO_TONE
	lda #$03
v_skctl equ *-1	
	sta $d20f
	EIF
	
	IFT FEAT_AGGRESSIVE_INIT
	sty old_v_audctl 
	EIF	
	
	ELI STEREOMODE==2		;* L1 R2 R3 L4
	lda trackn_audf+0
	ldx trackn_audc+0
	sta $d200
	stx $d201
	sta $d210
	lda trackn_audf+1
	ldx trackn_audc+1
	sta $d210+2
	stx $d211+2
	lda trackn_audf+2
	ldx trackn_audc+2
	sta $d210+4
	stx $d211+4
	sta $d200+4
	lda trackn_audf+3
	ldx trackn_audc+3
	sta $d200+6
	stx $d201+6
	sta $d210+6
	sty $d218
	sty $d208
	
	IFT FEAT_TWO_TONE
	lda #$03
v_skctl equ *-1	
	sta $d20f
	sta $d21f
	EIF
	
	IFT FEAT_AGGRESSIVE_INIT
	sty old_v_audctl 
	EIF
	
	ELI STEREOMODE==3		;* L1 L2 R3 R4
	lda trackn_audf+0
	ldx trackn_audc+0
	sta $d200
	stx $d201
	lda trackn_audf+1
	ldx trackn_audc+1
	sta $d200+2
	stx $d201+2
	lda trackn_audf+2
	ldx trackn_audc+2
	sta $d210+4
	stx $d211+4
	sta $d200+4
	lda trackn_audf+3
	ldx trackn_audc+3
	sta $d210+6
	stx $d211+6
	sta $d200+6
	sty $d218
	sty $d208
	
	IFT FEAT_TWO_TONE
	lda #$03
v_skctl equ *-1	
	sta $d20f
	sta $d21f
	EIF

	IFT FEAT_AGGRESSIVE_INIT
	sty old_v_audctl 
	EIF
	
	EIF
	rts
	
;* end of SetPokey routines...
	
;---------------------------------------------------------------------------------------------------------------------------------------------;
	
RMTPLAYEREND
	
;* Player ends here, what lies after is anything you want, and the extra workaround code if assembled as a 'tracker.obx' binary	

;---------------------------------------------------------------------------------------------------------------------------------------------;

;* Let's not forget the tables and other RMT data! 
	icl "rmtdata.a65"
	
;---------------------------------------------------------------------------------------------------------------------------------------------;
	
;* The workaround code is mandatory in order to avoid many things breaking in RMT!
	IFT FEAT_IS_TRACKER
	icl "rmtextra.a65" 
	EIF

;---------------------------------------------------------------------------------------------------------------------------------------------;

;* And that's all folks :D

